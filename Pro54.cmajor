//Pro54.cmajor
//
//     ,ad888ba,                              88
//    d8"'    "8b
//   d8            88,dba,,adba,   ,aPP8A.A8  88     The Cmajor Toolkit
//   Y8,           88    88    88  88     88  88
//    Y8a.   .a8P  88    88    88  88,   ,88  88     (C)2024 Cmajor Software Ltd
//     '"Y888Y"'   88    88    88  '"8bbP"Y8  88     https://cmajor.dev
//                                           ,88
//                                        888P"
//
//  The Cmajor project is subject to commercial or open-source licensing.
//  You may use it under the terms of the GPLv3 (see www.gnu.org/licenses), or
//  visit https://cmajor.dev to learn about our commercial licence options.
//
//  CMAJOR IS PROVIDED "AS IS" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER
//  EXPRESSED OR IMPLIED, INCLUDING MERCHANTABILITY AND FITNESS FOR PURPOSE, ARE
//  DISCLAIMED.

/**

  Pro-54: A Cmajor port of the Pro-53 instrument from Native Instruments

  This project is a great example of Cmajor being used to import old (possibly clunky!)
  codebases..

  If you read through this file, you'll spot many aspects of the code that are not such
  a great example of how to write maintainable code. For example:

  - It's all in one monolithic structure with all of the state in a single lump!
  - The main() function is over 1000 lines long (!!)
  - Lots of copy-pasted code rather than it being abstracted into functions or classes
  - Very little use of types to enforce compile-time correctness
  - Lots of hard-to-decipher names

  ..but while this isn't how you should write new code, when you're importing old codebases
  it's very common to end up dealing with this kind of

  So that actually makes this a great example of how you can take a creaky old C or C++
  project and bash it into a working Cmajor program without too much rewriting.
  In fact, old codebases like this one, which don't use any modern C++ syntax are
  particularly easy - a lot of the C syntax for expressions will work as Cmajor with
  only minor tweaks.

  Beyond just getting this running, we've given it a light tidy-up, just to get the code
  style into shape, to remove any really crusty bits, and improve some of the naming.

  Given infinite time, a much more elegant but difficult refactoring would involve splitting
  up the different functional units of the synth into separate Cmajor processors, and
  connecting them together in a graph.

*/


graph Pro54  [[main]]
{
    input engine.*;
    input event std::midi::Message midiIn   [[ name: "MIDI In" ]];
    output stream float<2> out              [[ name: "Audio Out" ]];

    node engine = Engine;

    connection std::midi::MPEConverter -> engine.eventIn;
    connection engine.out -> out;

    event midiIn (std::midi::Message m)
    {
        std::midi::MPEConverter.parseMIDI <- m;
    }
}

/// As discussed above, this processor is just a simple holder for the original C++
/// instrument code, rendering everything manually inside its main() loop
processor Engine
{
    output stream float<2> out;

    input event (std::notes::NoteOn,
                 std::notes::NoteOff,
                 std::notes::PitchBend,
                 std::notes::Control) eventIn;

    input stream float externalIn              [[ name: "External Audio In" ]];

    input event float PolyModFilterEnv         [[ name: "PolyMod Source Filt Env"     , unit: "%"  , min: 0.0, max: 100.0, init: 37.7953 ]];
    input event float PolyModOscB              [[ name: "PolyMod Source Osc B"        , unit: "%"  , min: 0.0, max: 100.0, init: 50.3937 ]];
    input event float PolyModFreqA             [[ name: "PolyMod Dest Freq A"         , unit: ""   , min: 0.0, max: 1.0,   init: 1.0, text:"Off|On", boolean ]];
    input event float PolyModPWA               [[ name: "PolyMod Dest PWidth A"       , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float PolyModFilt              [[ name: "PolyMod Dest Filter"         , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float OscAFreq                 [[ name: "Oscillator A Frequency"      , unit: "st" , min: 0.0, max: 100.0, init: 63.7795 ]];
    input event float OscASaw                  [[ name: "Oscillator A Sawtooth"       , unit: ""   , min: 0.0, max: 1.0,   init: 1.0, text:"Off|On", boolean ]];
    input event float OscAPulse                [[ name: "Oscillator A Pulse"          , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float OscAPW                   [[ name: "Oscillator A PulseWidth"     , unit: "%"  , min: 0.0, max: 100.0, init: 19.685 ]];
    input event float OscASync                 [[ name: "Oscillator A Sync"           , unit: ""   , min: 0.0, max: 1.0,   init: 1.0, text:"Off|On", boolean ]];
    input event float MixerOscALevel           [[ name: "Mixer Oscillator A"          , unit: "%"  , min: 0.0, max: 100.0, init: 61.4173 ]];
    input event float MixerOscBLevel           [[ name: "Mixer Oscillator B"          , unit: "%"  , min: 0.0, max: 100.0, init: 100.0 ]];
    input event float MixerNoiseLevel          [[ name: "Mixer Noise"                 , unit: "%"  , min: 0.0, max: 100.0, init: 0.0 ]];
    input event float ExternalInputLevel       [[ name: "Mixer External Input"        , unit: "%"  , min: 0.0, max: 100.0, init: 0.0 ]];
    input event float FilterCutoff             [[ name: "Filter Cutoff"               , unit: "st" , min: 0.0, max: 100.0, init: 29.9213 ]];
    input event float FilterResonance          [[ name: "Filter Resonance"            , unit: "%"  , min: 0.0, max: 100.0, init: 29.1339 ]];
    input event float FilterEnvAmt             [[ name: "Filter Envelope Amount"      , unit: "st" , min: 0.0, max: 100.0, init: 37.0079 ]];
    input event float FilterKeyboardTracking   [[ name: "Filter Keyboard Follow"      , unit: "%"  , min: 0.0, max: 100.0, init: 100.0 ]];
    input event float FilterAttack             [[ name: "Filter Attack"               , unit: "%"  , min: 0.0, max: 100.0, init: 0.0 ]];
    input event float FilterDecay              [[ name: "Filter Decay"                , unit: "%"  , min: 0.0, max: 100.0, init: 68.5039 ]];
    input event float FilterSustain            [[ name: "Filter Sustain"              , unit: "%"  , min: 0.0, max: 100.0, init: 0.0 ]];
    input event float FilterRelease            [[ name: "Filter Release"              , unit: "%"  , min: 0.0, max: 100.0, init: 65.3543 ]];
    input event float DelayTime                [[ name: "Delay Effect Time"           , unit: "ms" , min: 0.0, max: 100.0, init: 68.5039 ]];
    input event float DelaySpread              [[ name: "Delay Effect Spread"         , unit: "%"  , min: 0.0, max: 100.0, init: 41.7323 ]];
    input event float DelayDepth               [[ name: "Delay Effect Depth"          , unit: "ms" , min: 0.0, max: 100.0, init: 0.0 ]];
    input event float DelayRate                [[ name: "Delay Effect Rate"           , unit: "Hz" , min: 0.0, max: 100.0, init: 0.0 ]];
    input event float DelayFeedback            [[ name: "Delay Effect Feedback"       , unit: "%"  , min: 0.0, max: 100.0, init: 26.7717 ]];
    input event float DelayHiCut               [[ name: "Delay Effect High Cut"       , unit: "st" , min: 0.0, max: 100.0, init: 30.7087 ]];
    input event float DelayLoCut               [[ name: "Delay Effect Low Cut"        , unit: "st" , min: 0.0, max: 100.0, init: 70.0787 ]];
    input event float DelayINV                 [[ name: "Delay Effect Invert"         , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float DelayON                  [[ name: "Delay Effect On"             , unit: ""   , min: 0.0, max: 1.0,   init: 1.0, text:"Off|On", boolean ]];
    input event float DelayWet                 [[ name: "Delay Effect Wet"            , unit: "%"  , min: 0.0, max: 100.0, init: 20.4724 ]];
    input event float DelaySync                [[ name: "Delay Effect Sync"           , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float DelayMidi                [[ name: "Delay Effect MIDI Sync"      , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float LfoMidiSync              [[ name: "LFO MIDI Sync"               , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float LfoFrequency             [[ name: "LFO Frequency"               , unit: "Hz" , min: 0.0, max: 100.0, init: 73.2283 ]];
    input event float LfoShapeSaw              [[ name: "LFO Sawtooth"                , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float LfoShapeTri              [[ name: "LFO Triangle"                , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float LfoShapePulse            [[ name: "LFO Pulse"                   , unit: ""   , min: 0.0, max: 1.0,   init: 1.0, text:"Off|On", boolean ]];
    input event float OscBFreq                 [[ name: "Oscillator B Frequency"      , unit: "st" , min: 0.0, max: 100.0, init: 25.1968 ]];
    input event float OscBFreqFine             [[ name: "Oscillator B Freq Fine"      , unit: "ct" , min: 0.0, max: 100.0, init: 0.0 ]];
    input event float OscBShapeSaw             [[ name: "Oscillator B Sawtooth"       , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float OscBShapeTri             [[ name: "Oscillator B Triangle"       , unit: ""   , min: 0.0, max: 1.0,   init: 1.0, text:"Off|On", boolean ]];
    input event float OscBShapePulse           [[ name: "Oscillator B Pulse"          , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float OscBPWAmount             [[ name: "Oscillator B PulseWidth"     , unit: "%"  , min: 0.0, max: 100.0, init: 11.0236 ]];
    input event float OscBSubOsc               [[ name: "Oscillator B Low Freq"       , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float OscBKKeyboardTracking    [[ name: "Oscillator B Key Follow"     , unit: ""   , min: 0.0, max: 1.0,   init: 1.0, text:"Off|On", boolean ]];
    input event float WheelModulationLfoNoise  [[ name: "WheelMod LFO-Noise Mix"      , unit: "%"  , min: 0.0, max: 100.0, init: 0.0 ]];
    input event float WheelModulationFreqOscA  [[ name: "WheelMod Dest Freq A"        , unit: ""   , min: 0.0, max: 1.0,   init: 1.0, text:"Off|On", boolean ]];
    input event float WheelModulationFreqOscB  [[ name: "WheelMod Dest Freq B"        , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float WheelModulationPWA       [[ name: "WheelMod Dest PWidth A"      , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float WheelModulationPWB       [[ name: "WheelMod Dest PWidth B"      , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float WheelModulationFilter    [[ name: "WheelMod Dest Filter"        , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float Glide                    [[ name: "Glide Time"                  , unit: "%"  , min: 0.0, max: 100.0, init: 0.0 ]];
    input event float Unison                   [[ name: "Unisono Mode"                , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float AmplifierAttack          [[ name: "Amplifier Attack"            , unit: "%"  , min: 0.0, max: 100.0, init: 0.0 ]];
    input event float AmplifierDecay           [[ name: "Amplifier Decay"             , unit: "%"  , min: 0.0, max: 100.0, init: 61.4173 ]];
    input event float AmplifierSustain         [[ name: "Amplifier Sustain"           , unit: "%"  , min: 0.0, max: 100.0, init: 71.6535 ]];
    input event float AmplifierRelease         [[ name: "Amplifier Release"           , unit: "%"  , min: 0.0, max: 100.0, init: 37.7953 ]];
    input event float Release                  [[ name: "Release on/off"              , unit: ""   , min: 0.0, max: 1.0,   init: 1.0, text:"Off|On", boolean ]];
    input event float Velocity                 [[ name: "Velocity on/off"             , unit: ""   , min: 0.0, max: 1.0,   init: 1.0, text:"Off|On", boolean ]];
    input event float Repeat                   [[ name: "LFO Envelope Trigger"        , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float Drone                    [[ name: "Amplifier Hold"              , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float FilterHPF                [[ name: "Filter HPF-Mode"             , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float FilterInvertEnv          [[ name: "Filter Envelope Invert"      , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];
    input event float Analog                   [[ name: "Analog"                      , unit: "%"  , min: 0.0, max: 100.0, init: 33.0709 ]];
    input event float MasterTune               [[ name: "Master Tune"                 , unit: "ct" , min: 0.0, max: 100.0, init: 50.0 ]];
    input event float Volume                   [[ name: "Master Volume"               , unit: "%"  , min: 0.0, max: 100.0, init: 100.0 ]];

    input event float ModWheel                 [[ name: "Modulation Wheel"            , unit: "%"  , min: 0.0, max: 100.0, init: 0.0 ]];
    input event float PitchBend                [[ name: "Pitch Bend"                  , unit: "ct" , min: 0.0, max: 100.0, init: 50.0 ]];
    input event float FilterVersion            [[ name: "Filter Version"              , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Old|New|New AA" ]];
    input event float ActiveVoices             [[ name: "Active Voices"               , unit: ""   , min: 1.0, max: 32.0,  init: 5.0, step: 1.0 ]];
    input event float TestTone                 [[ name: "Test Tone"                   , unit: ""   , min: 0.0, max: 1.0,   init: 0.0, text:"Off|On", boolean ]];

    //==============================================================================
    //==============================================================================
    // Constants:

    let numVoices = 32;
    let controlPeriod = 1;
    let delayMask = 0x1ffff;
    let delayLength = delayMask + 1;
    let envelopeAOffset = -0.02f;
    let A440Pulse = 1.66f;
    let inputVolume = 25.0f;
    let masterVolume = 0.224f;
    let noteOffMarker = -300;
    let knobSmoothingTime = 20;

    let tau = float (1.0 / processor.frequency);
    let tauFilter = float (6.283 / processor.frequency);
    let piOverSampleRate = float (pi / processor.frequency);
    let noiseScale = float (sqrt (processor.frequency / 44100) * 4.6566129e-10);


    let defaultPickupTolerance = 0.025f;

    let initialGUICutoff = 29.9213f; //PICKUP CC
    let initialGUIResonance = 29.1339f; //PICKUP CC
    let initialGUIPolyModFilterEnv = 0.377953f;
    let initialGUIPolyModOscB = 0.503937f;
    let initialGUIOscAFreq = 0.637795f;
    let initialGUIOscAPW = 0.19685f;
    let initialGUIMixerOscALevel = 0.614173f;
    let initialGUIMixerOscBLevel = 1.0f;
    let initialGUIMixerNoiseLevel = 0.0f;
    let initialGUIExternalInputLevel = 0.0f;
    let initialGUIFilterEnvAmt = 0.370079f;
    let initialGUIFilterKeyboardTracking = 1.0f;
    let initialGUIFilterAttack = 0.0f;
    let initialGUIFilterDecay = 0.685039f;
    let initialGUIFilterSustain = 0.0f;
    let initialGUIFilterRelease = 0.653543f;
    let initialGUIDelayTime = 0.685039f;
    let initialGUIDelaySpread = 0.417323f;
    let initialGUIDelayDepth = 0.0f;
    let initialGUIDelayRate = 0.0f;
    let initialGUIDelayFeedback = 0.267717f;
    let initialGUIDelayHiCut = 0.307087f;
    let initialGUIDelayLoCut = 0.700787f;
    let initialGUIDelayWet = 0.204724f;
    let initialGUILfoFrequency = 0.732283f;
    let initialGUIOscBFreq = 0.251968f;
    let initialGUIOscBFreqFine = 0.0f;
    let initialGUIOscBPWAmount = 0.110236f;
    let initialGUIWheelModulationLfoNoise = 0.0f;
    let initialGUIGlide = 0.0f;
    let initialGUIAmplifierAttack = 0.0f;
    let initialGUIAmplifierDecay = 0.614173f;
    let initialGUIAmplifierSustain = 0.716535f;
    let initialGUIAmplifierRelease = 0.377953f;
    let initialGUIAnalog = 0.330709f;
    let initialGUIMasterTune = 0.50f;
    let initialGUIVolume = 1.0f;
    //==============================================================================
    //==============================================================================
    // State:

    MonoSignals state;
    VoiceState[numVoices] voices;
    float[delayLength] delayBuffer;
    bool testToneActive;
    bool sustainActive;  // SUSTPEDAL: This will now be the *effective* sustain
    bool pedalSustainActive; // SUSTPEDAL: New. Tracks CC64 state.
    bool pedalSostenutoActive; // SOSTPEDAL: New. Tracks CC66 state.
    // bool sostenutoHeld; // SOSTPEDAL: REMOVED. Individual voice sostenuto state is in VoiceState.
    int filterVersion;
    int lastUnison;
    int youngestOffVoice = -1;
    int oldestVoice = -1;
    int activeVoices = 5;

    int[numVoices] collVoiceNext, collVoicePrev, collVoiceNote;
    bool[numVoices] collVoiceSustain, collVoiceHold;

    float[2401] exponentLUT;
    float[2400] exponentLUTSlope;


    // State variables for MIDI CC Pickup Mode for Filter Cutoff
    float filterCutoff_lastGuiValueNormalized; // Stores the 0.0-1.0 value last set by GUI
    bool filterCutoff_ccArmed;
    float filterCutoff_pickupTolerance; // Small tolerance for matching, e.g., 0.02 (2% of 0-1 range)

    // State variables for MIDI CC Pickup Mode for Filter Resonance
    float filterResonance_lastGuiValueNormalized;
    bool filterResonance_ccArmed;
    float filterResonance_pickupTolerance;

// State variables for MIDI CC Pickup Mode for PolyModFilterEnv
    float polyModFilterEnv_lastGuiValueNormalized;
    bool  polyModFilterEnv_ccArmed;

    // State variables for MIDI CC Pickup Mode for PolyModOscB
    float polyModOscB_lastGuiValueNormalized;
    bool  polyModOscB_ccArmed;

    // State variables for MIDI CC Pickup Mode for OscAFreq
    float oscAFreq_lastGuiValueNormalized;
    bool  oscAFreq_ccArmed;

    // State variables for MIDI CC Pickup Mode for OscAPW
    float oscAPW_lastGuiValueNormalized;
    bool  oscAPW_ccArmed;

    // State variables for MIDI CC Pickup Mode for MixerOscALevel
    float mixerOscALevel_lastGuiValueNormalized;
    bool  mixerOscALevel_ccArmed;

    // State variables for MIDI CC Pickup Mode for MixerOscBLevel
    float mixerOscBLevel_lastGuiValueNormalized;
    bool  mixerOscBLevel_ccArmed;

    // State variables for MIDI CC Pickup Mode for MixerNoiseLevel
    float mixerNoiseLevel_lastGuiValueNormalized;
    bool  mixerNoiseLevel_ccArmed;

    // State variables for MIDI CC Pickup Mode for ExternalInputLevel
    float externalInputLevel_lastGuiValueNormalized;
    bool  externalInputLevel_ccArmed;

    // State variables for MIDI CC Pickup Mode for FilterEnvAmt
    float filterEnvAmt_lastGuiValueNormalized;
    bool  filterEnvAmt_ccArmed;

    // State variables for MIDI CC Pickup Mode for FilterKeyboardTracking
    float filterKeyboardTracking_lastGuiValueNormalized;
    bool  filterKeyboardTracking_ccArmed;

    // State variables for MIDI CC Pickup Mode for FilterAttack
    float filterAttack_lastGuiValueNormalized;
    bool  filterAttack_ccArmed;

    // State variables for MIDI CC Pickup Mode for FilterDecay
    float filterDecay_lastGuiValueNormalized;
    bool  filterDecay_ccArmed;

    // State variables for MIDI CC Pickup Mode for FilterSustain
    float filterSustain_lastGuiValueNormalized;
    bool  filterSustain_ccArmed;

    // State variables for MIDI CC Pickup Mode for FilterRelease
    float filterRelease_lastGuiValueNormalized;
    bool  filterRelease_ccArmed;

    // State variables for MIDI CC Pickup Mode for DelayTime
    float delayTime_lastGuiValueNormalized;
    bool  delayTime_ccArmed;

    // State variables for MIDI CC Pickup Mode for DelaySpread
    float delaySpread_lastGuiValueNormalized;
    bool  delaySpread_ccArmed;

    // State variables for MIDI CC Pickup Mode for DelayDepth
    float delayDepth_lastGuiValueNormalized;
    bool  delayDepth_ccArmed;

    // State variables for MIDI CC Pickup Mode for DelayRate
    float delayRate_lastGuiValueNormalized;
    bool  delayRate_ccArmed;

    // State variables for MIDI CC Pickup Mode for DelayFeedback
    float delayFeedback_lastGuiValueNormalized;
    bool  delayFeedback_ccArmed;

    // State variables for MIDI CC Pickup Mode for DelayHiCut
    float delayHiCut_lastGuiValueNormalized;
    bool  delayHiCut_ccArmed;

    // State variables for MIDI CC Pickup Mode for DelayLoCut
    float delayLoCut_lastGuiValueNormalized;
    bool  delayLoCut_ccArmed;

    // State variables for MIDI CC Pickup Mode for DelayWet
    float delayWet_lastGuiValueNormalized;
    bool  delayWet_ccArmed;

    // State variables for MIDI CC Pickup Mode for LfoFrequency
    float lfoFrequency_lastGuiValueNormalized;
    bool  lfoFrequency_ccArmed;

    // State variables for MIDI CC Pickup Mode for OscBFreq
    float oscBFreq_lastGuiValueNormalized;
    bool  oscBFreq_ccArmed;

    // State variables for MIDI CC Pickup Mode for OscBFreqFine
    float oscBFreqFine_lastGuiValueNormalized;
    bool  oscBFreqFine_ccArmed;

    // State variables for MIDI CC Pickup Mode for OscBPWAmount
    float oscBPWAmount_lastGuiValueNormalized;
    bool  oscBPWAmount_ccArmed;

    // State variables for MIDI CC Pickup Mode for WheelModulationLfoNoise
    float wheelModulationLfoNoise_lastGuiValueNormalized;
    bool  wheelModulationLfoNoise_ccArmed;

    // State variables for MIDI CC Pickup Mode for Glide
    float glide_lastGuiValueNormalized;
    bool  glide_ccArmed;

    // State variables for MIDI CC Pickup Mode for AmplifierAttack
    float amplifierAttack_lastGuiValueNormalized;
    bool  amplifierAttack_ccArmed;

    // State variables for MIDI CC Pickup Mode for AmplifierDecay
    float amplifierDecay_lastGuiValueNormalized;
    bool  amplifierDecay_ccArmed;

    // State variables for MIDI CC Pickup Mode for AmplifierSustain
    float amplifierSustain_lastGuiValueNormalized;
    bool  amplifierSustain_ccArmed;

    // State variables for MIDI CC Pickup Mode for AmplifierRelease
    float amplifierRelease_lastGuiValueNormalized;
    bool  amplifierRelease_ccArmed;

    // State variables for MIDI CC Pickup Mode for Analog
    float analog_lastGuiValueNormalized;
    bool  analog_ccArmed;

    // State variables for MIDI CC Pickup Mode for MasterTune
    float masterTune_lastGuiValueNormalized;
    bool  masterTune_ccArmed;

    // State variables for MIDI CC Pickup Mode for Volume
    float volume_lastGuiValueNormalized;
    bool  volume_ccArmed;

    struct MonoSignals
    {
        float controlCount;
        int   knobSmoothingCounter;
        float glide;
        float glideFinal;
        float glideOut;
        float glideInc;

        float lfoPhase;
        float lfoFreq;
        float lfoSawA;
        float lfoTriangleA;
        float lfoPulseA;
        bool  lfoPulseSign;
        float lfoShA;
        float lfoSh;
        float lfoConst;

        int64 noiseMem;
        float noiseFilterFreq;
        float noiseFilterLPF;

        float lfoNoiseMix;
        float modulationWheel;

        float envelopeA_D_FAC;
        float envelopeA_R_FAC;
        float envelopeA_Rel;
        float envelopeA_Att;
        float envelopeA_Sus;

        float envelopeF_D_FAC;
        float envelopeF_R_FAC;
        float envelopeF_Rel;
        float envelopeF_Att;
        float envelopeF_Sus;

        float oscillatorB_PulseA;
        float oscillatorB_SawA;
        bool  oscillatorB_TriA;
        float oscillatorB_FM_WM;
        float oscillatorB_PW;
        float oscillatorB_PW_Inc;
        float oscillatorB_PW_WM;
        float oscillatorB_LOF;
        float oscillatorB_Keyboard;
        float oscillatorB_Freq;
        float oscillatorB_Pitch;
        float oscillatorB_Fine;

        float polymodOscillatorB;
        float polymodEnvelopeF;

        float oscillatorA_SawA;
        float oscillatorA_FM_WM;
        float oscillatorA_FM_PM;
        float oscillatorA_PW;
        float oscillatorA_PW_Inc;
        float oscillatorA_PW_WM;
        float oscillatorA_PW_PM;
        bool  oscillatorA_PulseActive;
        float oscillatorA_SawActive;
        float oscillatorA_Freq;
        bool  oscillatorSyncActive;

        float mixerOscillatorA;
        float mixerOscillatorA_Inc;
        float mixerOscillatorB;
        float mixerOscillatorB_Inc;
        float mixerNoise;
        float mixerExternal;

        float filter_WM;
        float filter_PM;
        float filter_Env;
        float filter_EnvInc;
        bool  filter_HPF;
        float filter_D;
        float filter_FMAX;
        float filter_Keyboard;
        float filter_KeyboardInc;
        float filter_Cutoff;
        float filter_Event;
        float filter_EventInc;
        float filter_Res;
        float filterN_D;
        float filterN_FMAX;
        float filter1HPF;

        int   smootherCount;
        float volumeSmooth;
        float volumeInc;
        bool  delayActive;
        float delayDrySmooth;
        float delayDryInc;
        float delayWetSmooth;
        float delayWetInc;
        float delayFeedbackSmooth;
        float delayFeedbackInc;
        float delay_HPF_F;
        float delay_HPF_LPF;
        float delay_LPF_F;
        float delay_LPF_LPF;
        float delayTime_Mod_1;
        float delayTime_Mod_2;
        float delayTime_Mod_3;
        float delayTime_Mod_4;
        float delayTime_Inc_1;
        float delayTime_Inc_2;
        float delayTime_Inc_3;
        float delayTime_Inc_4;
        int   delayBufferIn;

        float A440Freq;
        float A440Phase;
        float A440PulseSign;
        float A440FilterFreq;
        float A440FilterLPF;

        float filterEnvelopeFinal;
        float filterKeyboardFinal;
        float oscillatorA_PW_Final;
        float oscillatorB_PW_Final;
        float mixerOscillatorA_Final;
        float mixerOscillatorB_Final;

        float volumeFinal;
        float delayWetKnob;
        float delayWetFinal;
        float delayDryFinal;
        float delayFeedbackKnob;
        float delayFeedbackFinal;
        float delayInv;
        float delaySum;
        float delayTime;
        float delayTimeRatio;
        float delayTime_1;
        float delayTime_2;
        float delayTime_3;
        float delayTime_4;
        float delayRate;
        float delayRate_1;
        float delayRate_2;
        float delayRate_3;
        float delayRate_4;
        float delayDepthKnob;
        float delayDepth;
        float delayLFO_Pos_1;
        float delayLFO_Pos_2;
        float delayLFO_Pos_3;
        float delayLFO_Pos_4;
        float delaySpread;
        float delayMIDI;
        bool  delaySync;

        float lfoRatio;
        float midiTempo;
        float pitchBend;
        float masterTune;
        float tune;
        float velocityAmp;
        float velocityFilter;
        float filterEnvelopeInv;
        float envelopeRelease;
        bool  unisonActive;
        float unisonNote;
        bool  repeatActive;
        bool  droneActive;
        float unisonGate;

        float filter_K;
        float noiseScale;
    }

    struct VoiceState
    {
        bool isActive;
        float gate;
        bool sostenutoHeld; // SOSTPEDAL: New. For individual voice sostenuto state.
        float noteNumber;
        float pitch;
        float unisonRnd;
        float oscillatorA_Rnd;
        float oscillatorA_Tune;
        float oscillatorB_Rnd;
        float oscillatorB_Tune;

        float envelopeA_Out;
        float envelopeA_Level;
        float envelopeA_Peak;
        float envelopeA_Inc;
        float envelopeA_SDif;
        float envelopeA_Fac;
        int   envelopeA_Stage;

        float envelopeF_Out;
        float envelopeF_Level;
        float envelopeF_Peak;
        float envelopeF_Inc;
        float envelopeF_SDif;
        float envelopeF_Fac;
        int   envelopeF_Stage;

        float oscillatorB_F;
        float oscillatorB_Phase;
        float oscillatorB_Saw_AA2;
        float oscillatorB_Pulse_AA2;

        float polymodEnvRnd;

        float oscillatorA_F;
        float oscillatorA_Phase;
        float oscillatorA_Saw_AA2;
        float oscillatorA_Pulse_AA2;
        float eqLast;
        float filter_Event;
        float filter_BPF;
        float filter_LPF;
        float filter_F_Inc;
        float filter_F_Smooth;
        float filter_RND;
        float filterN_BPF;
        float filterN_LPF;
        float saturator_Out;
        float filter1HP_LPF;

        float filter_S0;
        float filter_S1;
        float filter_S2;
        float filter_S3;
        float filter_X;
        float filter_X_1;
        float filter_X_2;
        float filter_X_3;
        float filter_X_4;
        float filter_F0_4;
        float filter_F0_1;
        float filter_F0_2;
        float filter_F0_3;
        float filter_Mix;

        float oscillatorB_PW_OLD;
        int   oscillatorB_PulseLevel;
        int   oscillatorB_BUFWRITE;
        float[8] oscillatorB_BUF;
    }

    //==============================================================================
    //==============================================================================
    void init()
    {
        initExponentLUT();
        updateAllTauDependendSignals();

        // Initialize Pickup Mode states
        filterCutoff_lastGuiValueNormalized = initialGUICutoff * 0.01f; // Normalize
        filterCutoff_ccArmed = true; // Start armed, assuming controller might match initial state
        filterCutoff_pickupTolerance = 0.025f; // Tolerance (e.g., 2.5% of 0-1 range, ~3 MIDI steps)
        state.filter_Cutoff = -39.0f + float (int (120.0f * filterCutoff_lastGuiValueNormalized));

        filterResonance_lastGuiValueNormalized = initialGUIResonance * 0.01f; // Normalize
        filterResonance_ccArmed = true; // Start armed
        filterResonance_pickupTolerance = 0.025f;

polyModFilterEnv_lastGuiValueNormalized = initialGUIPolyModFilterEnv;
        polyModFilterEnv_ccArmed = true;
        // Apply initial synth state (already done by its input event init or separate call)
        // Example: let Knob_init = 0.4f + 4.7f * polyModFilterEnv_lastGuiValueNormalized; state.polymodEnvelopeF = Knob_init * Knob_init - 0.16f;

        // Initialize Pickup Mode for PolyModOscB
        polyModOscB_lastGuiValueNormalized = initialGUIPolyModOscB;
        polyModOscB_ccArmed = true;
        // state.polymodOscillatorB = 3.09f * polyModOscB_lastGuiValueNormalized;

        // Initialize Pickup Mode for OscAFreq
        oscAFreq_lastGuiValueNormalized = initialGUIOscAFreq;
        oscAFreq_ccArmed = true;
        // state.oscillatorA_Freq = float (-24 + int ((0.375f * 127.0f) * oscAFreq_lastGuiValueNormalized + 0.4f)) + 12;
        // (voice updates for oscAFreq typically happen in its event handler or a general updatePitch)

        // Initialize Pickup Mode for OscAPW
        oscAPW_lastGuiValueNormalized = initialGUIOscAPW;
        oscAPW_ccArmed = true;
        // state.oscillatorA_PW_Final = oscAPW_lastGuiValueNormalized * 2.0f - 1.0f;
        // (smoothValue() would be called if this was a direct init action)

        // Initialize Pickup Mode for MixerOscALevel
        mixerOscALevel_lastGuiValueNormalized = initialGUIMixerOscALevel;
        mixerOscALevel_ccArmed = true;

        // Initialize Pickup Mode for MixerOscBLevel
        mixerOscBLevel_lastGuiValueNormalized = initialGUIMixerOscBLevel;
        mixerOscBLevel_ccArmed = true;

        // Initialize Pickup Mode for MixerNoiseLevel
        mixerNoiseLevel_lastGuiValueNormalized = initialGUIMixerNoiseLevel;
        mixerNoiseLevel_ccArmed = true;

        // Initialize Pickup Mode for ExternalInputLevel
        externalInputLevel_lastGuiValueNormalized = initialGUIExternalInputLevel;
        externalInputLevel_ccArmed = true;

        // Initialize Pickup Mode for FilterEnvAmt
        filterEnvAmt_lastGuiValueNormalized = initialGUIFilterEnvAmt;
        filterEnvAmt_ccArmed = true;

        // Initialize Pickup Mode for FilterKeyboardTracking
        filterKeyboardTracking_lastGuiValueNormalized = initialGUIFilterKeyboardTracking;
        filterKeyboardTracking_ccArmed = true;

        // Initialize Pickup Mode for FilterAttack
        filterAttack_lastGuiValueNormalized = initialGUIFilterAttack;
        filterAttack_ccArmed = true;

        // Initialize Pickup Mode for FilterDecay
        filterDecay_lastGuiValueNormalized = initialGUIFilterDecay;
        filterDecay_ccArmed = true;

        // Initialize Pickup Mode for FilterSustain
        filterSustain_lastGuiValueNormalized = initialGUIFilterSustain;
        filterSustain_ccArmed = true;

        // Initialize Pickup Mode for FilterRelease
        filterRelease_lastGuiValueNormalized = initialGUIFilterRelease;
        filterRelease_ccArmed = true;

        // Initialize Pickup Mode for DelayTime
        delayTime_lastGuiValueNormalized = initialGUIDelayTime;
        delayTime_ccArmed = true;

        // Initialize Pickup Mode for DelaySpread
        delaySpread_lastGuiValueNormalized = initialGUIDelaySpread;
        delaySpread_ccArmed = true;

        // Initialize Pickup Mode for DelayDepth
        delayDepth_lastGuiValueNormalized = initialGUIDelayDepth;
        delayDepth_ccArmed = true;

        // Initialize Pickup Mode for DelayRate
        delayRate_lastGuiValueNormalized = initialGUIDelayRate;
        delayRate_ccArmed = true;

        // Initialize Pickup Mode for DelayFeedback
        delayFeedback_lastGuiValueNormalized = initialGUIDelayFeedback;
        delayFeedback_ccArmed = true;

        // Initialize Pickup Mode for DelayHiCut
        delayHiCut_lastGuiValueNormalized = initialGUIDelayHiCut;
        delayHiCut_ccArmed = true;

        // Initialize Pickup Mode for DelayLoCut
        delayLoCut_lastGuiValueNormalized = initialGUIDelayLoCut;
        delayLoCut_ccArmed = true;

        // Initialize Pickup Mode for DelayWet
        delayWet_lastGuiValueNormalized = initialGUIDelayWet;
        delayWet_ccArmed = true;

        // Initialize Pickup Mode for LfoFrequency
        lfoFrequency_lastGuiValueNormalized = initialGUILfoFrequency;
        lfoFrequency_ccArmed = true;

        // Initialize Pickup Mode for OscBFreq
        oscBFreq_lastGuiValueNormalized = initialGUIOscBFreq;
        oscBFreq_ccArmed = true;

        // Initialize Pickup Mode for OscBFreqFine
        oscBFreqFine_lastGuiValueNormalized = initialGUIOscBFreqFine;
        oscBFreqFine_ccArmed = true;

        // Initialize Pickup Mode for OscBPWAmount
        oscBPWAmount_lastGuiValueNormalized = initialGUIOscBPWAmount;
        oscBPWAmount_ccArmed = true;

        // Initialize Pickup Mode for WheelModulationLfoNoise
        wheelModulationLfoNoise_lastGuiValueNormalized = initialGUIWheelModulationLfoNoise;
        wheelModulationLfoNoise_ccArmed = true;

        // Initialize Pickup Mode for Glide
        glide_lastGuiValueNormalized = initialGUIGlide;
        glide_ccArmed = true;

        // Initialize Pickup Mode for AmplifierAttack
        amplifierAttack_lastGuiValueNormalized = initialGUIAmplifierAttack;
        amplifierAttack_ccArmed = true;

        // Initialize Pickup Mode for AmplifierDecay
        amplifierDecay_lastGuiValueNormalized = initialGUIAmplifierDecay;
        amplifierDecay_ccArmed = true;

        // Initialize Pickup Mode for AmplifierSustain
        amplifierSustain_lastGuiValueNormalized = initialGUIAmplifierSustain;
        amplifierSustain_ccArmed = true;

        // Initialize Pickup Mode for AmplifierRelease
        amplifierRelease_lastGuiValueNormalized = initialGUIAmplifierRelease;
        amplifierRelease_ccArmed = true;

        // Initialize Pickup Mode for Analog
        analog_lastGuiValueNormalized = initialGUIAnalog;
        analog_ccArmed = true;

        // Initialize Pickup Mode for MasterTune
        masterTune_lastGuiValueNormalized = initialGUIMasterTune;
        masterTune_ccArmed = true;

        // Initialize Pickup Mode for Volume
        volume_lastGuiValueNormalized = initialGUIVolume;
        volume_ccArmed = true;

        pedalSustainActive = true; // SUSTPEDAL: New. Initialize pedal state.
        // pedalSostenutoActive is initialized to false by default for bools, or can be explicitly set if needed.
        // The line `sostenutoHeld = false;` that referred to Engine::sostenutoHeld was removed as the state variable itself was removed.
        state.A440Phase = 0;
        state.smootherCount = 0;
        state.volumeSmooth = 0;
        state.delayDrySmooth = 0;
        state.delayWetSmooth = 0;
        state.delayFeedbackSmooth = 0;
        state.filterEnvelopeInv = 1;
        state.glideOut = 36;
        state.controlCount = 100;
        state.noiseMem = 1;

        for (wrap<numVoices> i)
        {
            collVoiceSustain[i] = false;
            collVoiceHold[i] = false;
            collVoiceNote[i] = noteOffMarker;
        }
        pedalSustainActive = false;
        allSoundOff();
        updateEffectiveSustain();
    }

    //==============================================================================
    //==============================================================================
    // Event handlers:

    //===MIDI EVENTS===
    event eventIn (std::notes::NoteOn e)       { noteOn  (int (e.pitch), int (e.velocity * 128.0f), 0.0f); }
    event eventIn (std::notes::NoteOff e)      { noteOff (int (e.pitch), int (e.velocity * 128.0f)); }
    event eventIn (std::notes::PitchBend e)    { setPitchBend (0.5f + 0.5f * (e.bendSemitones / 48.0f)); }
    event eventIn (std::notes::Control e)
    {
        if (e.control == 1) // Mod Wheel (CC 1)
        {
            setModWheel(e.value); // e.value is already 0-1 from MPEConverter
        }
        // Knob MIDI CCs with Pickup
        else if (e.control == 70) // Filter Cutoff (CC 70)
        {
            float ccValueNormalized = e.value;
            if (!filterCutoff_ccArmed)
            {
                if (abs(ccValueNormalized - filterCutoff_lastGuiValueNormalized) <= filterCutoff_pickupTolerance)
                {
                    filterCutoff_ccArmed = true;
                    state.filter_Cutoff = -39.0f + float (int (120.0f * ccValueNormalized));
                    smoothValue();
                }
            }
            if (filterCutoff_ccArmed)
            {
                state.filter_Cutoff = -39.0f + float (int (120.0f * ccValueNormalized));
                smoothValue();
            }
        }
        else if (e.control == 71) // Filter Resonance (CC 71)
        {
            float ccValueNormalized = e.value;
            if (!filterResonance_ccArmed)
            {
                if (abs(ccValueNormalized - filterResonance_lastGuiValueNormalized) <= filterResonance_pickupTolerance)
                {
                    filterResonance_ccArmed = true;
                    // Apply synth logic from FilterResonance event
                    state.filter_Res = ccValueNormalized;
                    float Res;
                    if (state.filter_Res < 0.25f) Res = 2.32f * state.filter_Res;
                    else if (state.filter_Res < 0.5f) Res = 0.52f * state.filter_Res + 0.45f;
                    else if (state.filter_Res < 0.75f) Res = 0.92f * state.filter_Res + 0.25f;
                    else Res = 0.036f * state.filter_Res + 0.913f;
                    state.filter_D = 2.0f - 2.0f * Res; state.filter_K = 4.1f * ccValueNormalized;
                    if (state.filter_HPF) state.filter_FMAX = 0.5f + 0.0318f * Res * (27.5989f + Res);
                    else state.filter_FMAX = 0.7352f + 0.2930f * Res * (1.3075f + Res);
                    Res *= 0.8f; state.filterN_D = 2.0f - 2.0f * Res;
                    if (state.filter_HPF) state.filterN_FMAX = 0.5f + 0.0318f * Res * (27.5989f + Res);
                    else state.filterN_FMAX = 0.7352f + 0.2930f * Res * (1.3075f + Res);
                    smoothValue();
                }
            }
            if (filterResonance_ccArmed)
            {
                // Apply synth logic from FilterResonance event
                state.filter_Res = ccValueNormalized;
                float Res;
                if (state.filter_Res < 0.25f) Res = 2.32f * state.filter_Res;
                else if (state.filter_Res < 0.5f) Res = 0.52f * state.filter_Res + 0.45f;
                else if (state.filter_Res < 0.75f) Res = 0.92f * state.filter_Res + 0.25f;
                else Res = 0.036f * state.filter_Res + 0.913f;
                state.filter_D = 2.0f - 2.0f * Res; state.filter_K = 4.1f * ccValueNormalized;
                if (state.filter_HPF) state.filter_FMAX = 0.5f + 0.0318f * Res * (27.5989f + Res);
                else state.filter_FMAX = 0.7352f + 0.2930f * Res * (1.3075f + Res);
                Res *= 0.8f; state.filterN_D = 2.0f - 2.0f * Res;
                if (state.filter_HPF) state.filterN_FMAX = 0.5f + 0.0318f * Res * (27.5989f + Res);
                else state.filterN_FMAX = 0.7352f + 0.2930f * Res * (1.3075f + Res);
                smoothValue();
            }
        }
        // --- PolyModFilterEnv (CC 20) ---
        else if (e.control == 20)
        {
            float ccValueNormalized = e.value;
            if (!polyModFilterEnv_ccArmed)
            {
                if (abs(ccValueNormalized - polyModFilterEnv_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    polyModFilterEnv_ccArmed = true;
                    let Knob = 0.4f + 4.7f * ccValueNormalized;
                    state.polymodEnvelopeF = Knob * Knob - 0.16f;
                }
            }
            if (polyModFilterEnv_ccArmed)
            {
                let Knob = 0.4f + 4.7f * ccValueNormalized;
                state.polymodEnvelopeF = Knob * Knob - 0.16f;
            }
        }
        // --- PolyModOscB (CC 21) ---
        else if (e.control == 21)
        {
            float ccValueNormalized = e.value;
            if (!polyModOscB_ccArmed)
            {
                if (abs(ccValueNormalized - polyModOscB_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    polyModOscB_ccArmed = true;
                    state.polymodOscillatorB = 3.09f * ccValueNormalized;
                }
            }
            if (polyModOscB_ccArmed)
            {
                state.polymodOscillatorB = 3.09f * ccValueNormalized;
            }
        }
        // --- OscAFreq (CC 40) ---
        else if (e.control == 40)
        {
            float ccValueNormalized = e.value;
            if (!oscAFreq_ccArmed)
            {
                if (abs(ccValueNormalized - oscAFreq_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    oscAFreq_ccArmed = true;
                    state.oscillatorA_Freq = float (-24 + int ((0.375f * 127.0f) * ccValueNormalized + 0.4f)) + 12;
                    for (wrap<numVoices> v_idx) { voices[v_idx].oscillatorA_Tune = state.oscillatorA_Freq + voices[v_idx].oscillatorA_Rnd + state.tune; voices[v_idx].oscillatorA_F = pitchToFreq (voices[v_idx].pitch + voices[v_idx].oscillatorA_Tune); }
                }
            }
            if (oscAFreq_ccArmed)
            {
                state.oscillatorA_Freq = float (-24 + int ((0.375f * 127.0f) * ccValueNormalized + 0.4f)) + 12;
                for (wrap<numVoices> v_idx) { voices[v_idx].oscillatorA_Tune = state.oscillatorA_Freq + voices[v_idx].oscillatorA_Rnd + state.tune; voices[v_idx].oscillatorA_F = pitchToFreq (voices[v_idx].pitch + voices[v_idx].oscillatorA_Tune); }
            }
        }
        // --- OscAPW (CC 43) ---
        else if (e.control == 43)
        {
            float ccValueNormalized = e.value;
            if (!oscAPW_ccArmed)
            {
                if (abs(ccValueNormalized - oscAPW_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    oscAPW_ccArmed = true;
                    state.oscillatorA_PW_Final = ccValueNormalized * 2.0f - 1.0f;
                    smoothValue();
                }
            }
            if (oscAPW_ccArmed)
            {
                state.oscillatorA_PW_Final = ccValueNormalized * 2.0f - 1.0f;
                smoothValue();
            }
        }
        // --- MixerOscALevel (CC 45) ---
        else if (e.control == 45)
        {
            float ccValueNormalized = e.value;
            if (!mixerOscALevel_ccArmed)
            {
                if (abs(ccValueNormalized - mixerOscALevel_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    mixerOscALevel_ccArmed = true;
                    state.mixerOscillatorA_Final = ccValueNormalized;
                    smoothValue();
                }
            }
            if (mixerOscALevel_ccArmed)
            {
                state.mixerOscillatorA_Final = ccValueNormalized;
                smoothValue();
            }
        }
        // --- MixerOscBLevel (CC 46) ---
        else if (e.control == 46)
        {
            float ccValueNormalized = e.value;
            if (!mixerOscBLevel_ccArmed)
            {
                if (abs(ccValueNormalized - mixerOscBLevel_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    mixerOscBLevel_ccArmed = true;
                    state.mixerOscillatorB_Final = 2.0f * ccValueNormalized;
                    smoothValue();
                }
            }
            if (mixerOscBLevel_ccArmed)
            {
                state.mixerOscillatorB_Final = 2.0f * ccValueNormalized;
                smoothValue();
            }
        }
        // --- MixerNoiseLevel (CC 47) ---
        else if (e.control == 47)
        {
            float ccValueNormalized = e.value;
            if (!mixerNoiseLevel_ccArmed)
            {
                if (abs(ccValueNormalized - mixerNoiseLevel_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    mixerNoiseLevel_ccArmed = true;
                    state.mixerNoise = 0.35f * 5.0f * ccValueNormalized;
                }
            }
            if (mixerNoiseLevel_ccArmed)
            {
                state.mixerNoise = 0.35f * 5.0f * ccValueNormalized;
            }
        }
        // --- ExternalInputLevel (CC 48) ---
        else if (e.control == 48)
        {
            float ccValueNormalized = e.value;
            if (!externalInputLevel_ccArmed)
            {
                if (abs(ccValueNormalized - externalInputLevel_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    externalInputLevel_ccArmed = true;
                    state.mixerExternal = inputVolume * ccValueNormalized;
                }
            }
            if (externalInputLevel_ccArmed)
            {
                state.mixerExternal = inputVolume * ccValueNormalized;
            }
        }
        // --- FilterEnvAmt (CC 72) ---
        else if (e.control == 72)
        {
            float ccValueNormalized = e.value;
            if (!filterEnvAmt_ccArmed)
            {
                if (abs(ccValueNormalized - filterEnvAmt_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    filterEnvAmt_ccArmed = true;
                    state.filterEnvelopeFinal = state.filterEnvelopeInv * 192.0f * ccValueNormalized;
                    smoothValue();
                }
            }
            if (filterEnvAmt_ccArmed)
            {
                state.filterEnvelopeFinal = state.filterEnvelopeInv * 192.0f * ccValueNormalized;
                smoothValue();
            }
        }
        // --- FilterKeyboardTracking (CC 73) ---
        else if (e.control == 73)
        {
            float ccValueNormalized = e.value;
            if (!filterKeyboardTracking_ccArmed)
            {
                if (abs(ccValueNormalized - filterKeyboardTracking_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    filterKeyboardTracking_ccArmed = true;
                    state.filterKeyboardFinal = ccValueNormalized; // Already 0-1
                    smoothValue();
                }
            }
            if (filterKeyboardTracking_ccArmed)
            {
                state.filterKeyboardFinal = ccValueNormalized;
                smoothValue();
            }
        }
        // --- FilterAttack (CC 75) ---
        else if (e.control == 75)
        {
            float ccValueNormalized = e.value;
            if (!filterAttack_ccArmed)
            {
                if (abs(ccValueNormalized - filterAttack_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    filterAttack_ccArmed = true;
                    state.envelopeF_Att = tau * timeToIncrement (-5.0f + 90.7f * ccValueNormalized);
                }
            }
            if (filterAttack_ccArmed)
            {
                state.envelopeF_Att = tau * timeToIncrement (-5.0f + 90.7f * ccValueNormalized);
            }
        }
        // --- FilterDecay (CC 76) ---
        else if (e.control == 76)
        {
            float ccValueNormalized = e.value;
            if (!filterDecay_ccArmed)
            {
                if (abs(ccValueNormalized - filterDecay_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    filterDecay_ccArmed = true;
                    let factor_cc = timeToIncrement (-3.0f + 85.0f * ccValueNormalized) * tau;
                    state.envelopeF_D_FAC = factor_cc > 1.0f ? 0.0f : (1.0f - factor_cc);
                    for (wrap<numVoices> v_idx) if (voices[v_idx].envelopeF_Stage == 1) voices[v_idx].envelopeF_Fac = state.envelopeF_D_FAC;
                }
            }
            if (filterDecay_ccArmed)
            {
                let factor_cc = timeToIncrement (-3.0f + 85.0f * ccValueNormalized) * tau;
                state.envelopeF_D_FAC = factor_cc > 1.0f ? 0.0f : (1.0f - factor_cc);
                for (wrap<numVoices> v_idx) if (voices[v_idx].envelopeF_Stage == 1) voices[v_idx].envelopeF_Fac = state.envelopeF_D_FAC;
            }
        }
        // --- FilterSustain (CC 77) ---
        else if (e.control == 77)
        {
            float ccValueNormalized = e.value;
            if (!filterSustain_ccArmed)
            {
                if (abs(ccValueNormalized - filterSustain_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    filterSustain_ccArmed = true;
                    state.envelopeF_Sus = 0.98f * ccValueNormalized;
                    for (wrap<numVoices> v_idx) { if (voices[v_idx].envelopeF_Stage == 1) { voices[v_idx].envelopeF_Level = state.envelopeF_Sus * voices[v_idx].envelopeF_Peak; voices[v_idx].envelopeF_SDif = voices[v_idx].envelopeF_Out - voices[v_idx].envelopeF_Level; } }
                }
            }
            if (filterSustain_ccArmed)
            {
                state.envelopeF_Sus = 0.98f * ccValueNormalized;
                for (wrap<numVoices> v_idx) { if (voices[v_idx].envelopeF_Stage == 1) { voices[v_idx].envelopeF_Level = state.envelopeF_Sus * voices[v_idx].envelopeF_Peak; voices[v_idx].envelopeF_SDif = voices[v_idx].envelopeF_Out - voices[v_idx].envelopeF_Level; } }
            }
        }
        // --- FilterRelease (CC 78) ---
        else if (e.control == 78)
        {
            float ccValueNormalized = e.value;
            if (!filterRelease_ccArmed)
            {
                if (abs(ccValueNormalized - filterRelease_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    filterRelease_ccArmed = true;
                    state.envelopeF_Rel = -10.0f + 92.7f * ccValueNormalized;
                    let factor_cc = timeToIncrement (state.envelopeRelease * state.envelopeF_Rel) * tau;
                    state.envelopeF_R_FAC = factor_cc > 1.0f ? 0.0f : (1.0f - factor_cc);
                    for (wrap<numVoices> v_idx) if (voices[v_idx].envelopeF_Stage == 2) voices[v_idx].envelopeF_Fac = state.envelopeF_R_FAC;
                }
            }
            if (filterRelease_ccArmed)
            {
                state.envelopeF_Rel = -10.0f + 92.7f * ccValueNormalized;
                let factor_cc = timeToIncrement (state.envelopeRelease * state.envelopeF_Rel) * tau;
                state.envelopeF_R_FAC = factor_cc > 1.0f ? 0.0f : (1.0f - factor_cc);
                for (wrap<numVoices> v_idx) if (voices[v_idx].envelopeF_Stage == 2) voices[v_idx].envelopeF_Fac = state.envelopeF_R_FAC;
            }
        }
        // --- DelayTime (CC 105) ---
        else if (e.control == 105)
        {
            float ccValueNormalized = e.value;
            if (!delayTime_ccArmed)
            {
                if (abs(ccValueNormalized - delayTime_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    delayTime_ccArmed = true;
                    float octave_cc = -8.97f + (1.0f + 8.97f) * ccValueNormalized; int octaveInt_cc = int (floor (octave_cc)); state.delayTimeRatio = 0.001953125f * float(1 << (octaveInt_cc + 9)); state.delayTimeRatio *= 60.0f; if (octave_cc - float(octaveInt_cc) > 0.58f) state.delayTimeRatio *= 1.5f; if (state.delayMIDI == 0.0f) state.delayTime = exp_dB (-60.0f + 60.0f * ccValueNormalized); computeDelayTimes();
                }
            }
            if (delayTime_ccArmed)
            {
                float octave_cc = -8.97f + (1.0f + 8.97f) * ccValueNormalized; int octaveInt_cc = int (floor (octave_cc)); state.delayTimeRatio = 0.001953125f * float(1 << (octaveInt_cc + 9)); state.delayTimeRatio *= 60.0f; if (octave_cc - float(octaveInt_cc) > 0.58f) state.delayTimeRatio *= 1.5f; if (state.delayMIDI == 0.0f) state.delayTime = exp_dB (-60.0f + 60.0f * ccValueNormalized); computeDelayTimes();
            }
        }
        // --- DelaySpread (CC 106) ---
        else if (e.control == 106)
        {
            float ccValueNormalized = e.value;
            if (!delaySpread_ccArmed)
            {
                if (abs(ccValueNormalized - delaySpread_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    delaySpread_ccArmed = true;
                    state.delaySpread = ccValueNormalized; computeDelayTimes();
                }
            }
            if (delaySpread_ccArmed)
            {
                state.delaySpread = ccValueNormalized; computeDelayTimes();
            }
        }
        // --- DelayDepth (CC 107) ---
        else if (e.control == 107)
        {
            float ccValueNormalized = e.value;
            if (!delayDepth_ccArmed)
            {
                if (abs(ccValueNormalized - delayDepth_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    delayDepth_ccArmed = true;
                    state.delayDepthKnob = ccValueNormalized > 0.0f ? exp_E (5.0f * ccValueNormalized) * 0.000185f : 0.0f; state.delayDepth = state.delayDepthKnob * float (processor.frequency); computeDelayTimes();
                }
            }
            if (delayDepth_ccArmed)
            {
                state.delayDepthKnob = ccValueNormalized > 0.0f ? exp_E (5.0f * ccValueNormalized) * 0.000185f : 0.0f; state.delayDepth = state.delayDepthKnob * float (processor.frequency); computeDelayTimes();
            }
        }
        // --- DelayRate (CC 108) ---
        else if (e.control == 108)
        {
            float ccValueNormalized = e.value;
            if (!delayRate_ccArmed)
            {
                if (abs(ccValueNormalized - delayRate_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    delayRate_ccArmed = true;
                    state.delayRate = pitchToFreq (-60.0f + 80.0f * ccValueNormalized); if (state.delaySync) { state.delayRate_1 = state.delayRate; } else { state.delayRate_1 = state.delayRate * 1.029f; state.delayRate_2 = state.delayRate * 0.917f; state.delayRate_3 = state.delayRate * 0.972f; state.delayRate_4 = state.delayRate * 1.091f; }
                }
            }
            if (delayRate_ccArmed)
            {
                state.delayRate = pitchToFreq (-60.0f + 80.0f * ccValueNormalized); if (state.delaySync) { state.delayRate_1 = state.delayRate; } else { state.delayRate_1 = state.delayRate * 1.029f; state.delayRate_2 = state.delayRate * 0.917f; state.delayRate_3 = state.delayRate * 0.972f; state.delayRate_4 = state.delayRate * 1.091f; }
            }
        }
        // --- DelayFeedback (CC 110) ---
        else if (e.control == 110)
        {
            float ccValueNormalized = e.value;
            if (!delayFeedback_ccArmed)
            {
                if (abs(ccValueNormalized - delayFeedback_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    delayFeedback_ccArmed = true;
                    state.delayFeedbackKnob = ccValueNormalized * 0.25f; state.delayFeedbackFinal = state.delayFeedbackKnob * state.delayInv * (1.0f - 0.5f * state.delay_HPF_F); smoother();
                }
            }
            if (delayFeedback_ccArmed)
            {
                state.delayFeedbackKnob = ccValueNormalized * 0.25f; state.delayFeedbackFinal = state.delayFeedbackKnob * state.delayInv * (1.0f - 0.5f * state.delay_HPF_F); smoother();
            }
        }
        // --- DelayHiCut (CC 112) ---
        else if (e.control == 112)
        {
            float ccValueNormalized = e.value;
            if (!delayHiCut_ccArmed)
            {
                if (abs(ccValueNormalized - delayHiCut_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    delayHiCut_ccArmed = true;
                    state.delay_HPF_F = min (0.99f, pitchToFreq (0.0f + 120.0f * ccValueNormalized) * tauFilter); state.delayFeedbackFinal = state.delayFeedbackKnob * state.delayInv * (1.0f - 0.5f * state.delay_HPF_F); smoother();
                }
            }
            if (delayHiCut_ccArmed)
            {
                state.delay_HPF_F = min (0.99f, pitchToFreq (0.0f + 120.0f * ccValueNormalized) * tauFilter); state.delayFeedbackFinal = state.delayFeedbackKnob * state.delayInv * (1.0f - 0.5f * state.delay_HPF_F); smoother();
            }
        }
        // --- DelayLoCut (CC 111) ---
        else if (e.control == 111)
        {
            float ccValueNormalized = e.value;
            if (!delayLoCut_ccArmed)
            {
                if (abs(ccValueNormalized - delayLoCut_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    delayLoCut_ccArmed = true;
                    state.delay_LPF_F = min (0.99f, pitchToFreq (40.0f + 80.0f * ccValueNormalized) * tauFilter);
                }
            }
            if (delayLoCut_ccArmed)
            {
                state.delay_LPF_F = min (0.99f, pitchToFreq (40.0f + 80.0f * ccValueNormalized) * tauFilter);
            }
        }
        // --- DelayWet (CC 116) ---
        else if (e.control == 116)
        {
            float ccValueNormalized = e.value;
            if (!delayWet_ccArmed)
            {
                if (abs(ccValueNormalized - delayWet_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    delayWet_ccArmed = true;
                    state.delayWetKnob = ccValueNormalized; if (state.delayActive) { state.delayWetFinal = state.delayWetKnob * (1.828f - 0.828f * state.delayWetKnob) * 0.5f * state.delayInv; state.delayDryFinal = (1.0f - state.delayWetKnob) * (1.828f - 0.828f * (1.0f - state.delayWetKnob)); smoother(); }
                }
            }
            if (delayWet_ccArmed)
            {
                state.delayWetKnob = ccValueNormalized; if (state.delayActive) { state.delayWetFinal = state.delayWetKnob * (1.828f - 0.828f * state.delayWetKnob) * 0.5f * state.delayInv; state.delayDryFinal = (1.0f - state.delayWetKnob) * (1.828f - 0.828f * (1.0f - state.delayWetKnob)); smoother(); }
            }
        }
        // --- LfoFrequency (CC 26) ---
        else if (e.control == 26)
        {
            float ccValueNormalized = e.value;
            if (!lfoFrequency_ccArmed)
            {
                if (abs(ccValueNormalized - lfoFrequency_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    lfoFrequency_ccArmed = true;
                    float octave_cc = -5.5f + 9.725f * ccValueNormalized; int octaveInt_cc = int (floor (octave_cc)); state.lfoRatio = 0.015625f * float(1 << (octaveInt_cc + 6)); if (octave_cc - float(octaveInt_cc) > 0.58f) state.lfoRatio *= 1.5f; if (state.midiTempo == 0.0f) state.lfoFreq = pitchToFreq (-92.7f + 116.7f * ccValueNormalized);
                }
            }
            if (lfoFrequency_ccArmed)
            {
                float octave_cc = -5.5f + 9.725f * ccValueNormalized; int octaveInt_cc = int (floor (octave_cc)); state.lfoRatio = 0.015625f * float(1 << (octaveInt_cc + 6)); if (octave_cc - float(octaveInt_cc) > 0.58f) state.lfoRatio *= 1.5f; if (state.midiTempo == 0.0f) state.lfoFreq = pitchToFreq (-92.7f + 116.7f * ccValueNormalized);
            }
        }
        // --- OscBFreq (CC 50) ---
        else if (e.control == 50)
        {
            float ccValueNormalized = e.value;
            if (!oscBFreq_ccArmed)
            {
                if (abs(ccValueNormalized - oscBFreq_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    oscBFreq_ccArmed = true;
                    state.oscillatorB_Freq = 0.375f * 127.0f * ccValueNormalized; state.oscillatorB_Pitch = 12.0f + 11.0f - 35.0f * state.oscillatorB_Keyboard + float (int ((2.0f - state.oscillatorB_Keyboard) * (state.oscillatorB_Freq + 0.4f)));
                    for (wrap<numVoices> v_idx) { voices[v_idx].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v_idx].oscillatorB_Rnd + state.tune; voices[v_idx].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v_idx].pitch + voices[v_idx].oscillatorB_Tune); }
                }
            }
            if (oscBFreq_ccArmed)
            {
                state.oscillatorB_Freq = 0.375f * 127.0f * ccValueNormalized; state.oscillatorB_Pitch = 12.0f + 11.0f - 35.0f * state.oscillatorB_Keyboard + float (int ((2.0f - state.oscillatorB_Keyboard) * (state.oscillatorB_Freq + 0.4f)));
                for (wrap<numVoices> v_idx) { voices[v_idx].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v_idx].oscillatorB_Rnd + state.tune; voices[v_idx].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v_idx].pitch + voices[v_idx].oscillatorB_Tune); }
            }
        }
        // --- OscBFreqFine (CC 51) ---
        else if (e.control == 51)
        {
            float ccValueNormalized = e.value;
            if (!oscBFreqFine_ccArmed)
            {
                if (abs(ccValueNormalized - oscBFreqFine_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    oscBFreqFine_ccArmed = true;
                    state.oscillatorB_Fine = 0.015f + 0.935f * ccValueNormalized;
                    for (wrap<numVoices> v_idx) { voices[v_idx].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v_idx].oscillatorB_Rnd + state.tune; voices[v_idx].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v_idx].pitch + voices[v_idx].oscillatorB_Tune); }
                }
            }
            if (oscBFreqFine_ccArmed)
            {
                state.oscillatorB_Fine = 0.015f + 0.935f * ccValueNormalized;
                for (wrap<numVoices> v_idx) { voices[v_idx].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v_idx].oscillatorB_Rnd + state.tune; voices[v_idx].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v_idx].pitch + voices[v_idx].oscillatorB_Tune); }
            }
        }
        // --- OscBPWAmount (CC 55) ---
        else if (e.control == 55)
        {
            float ccValueNormalized = e.value;
            if (!oscBPWAmount_ccArmed)
            {
                if (abs(ccValueNormalized - oscBPWAmount_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    oscBPWAmount_ccArmed = true;
                    state.oscillatorB_PW_Final = ccValueNormalized * 2.0f - 1.0f; smoothValue();
                }
            }
            if (oscBPWAmount_ccArmed)
            {
                state.oscillatorB_PW_Final = ccValueNormalized * 2.0f - 1.0f; smoothValue();
            }
        }
        // --- WheelModulationLfoNoise (CC 34) ---
        else if (e.control == 34)
        {
            float ccValueNormalized = e.value;
            if (!wheelModulationLfoNoise_ccArmed)
            {
                if (abs(ccValueNormalized - wheelModulationLfoNoise_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    wheelModulationLfoNoise_ccArmed = true;
                    state.lfoNoiseMix = ccValueNormalized;
                }
            }
            if (wheelModulationLfoNoise_ccArmed)
            {
                state.lfoNoiseMix = ccValueNormalized;
            }
        }
        // --- Glide (CC 5) ---
        else if (e.control == 5)
        {
            float ccValueNormalized = e.value;
            if (!glide_ccArmed)
            {
                if (abs(ccValueNormalized - glide_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    glide_ccArmed = true;
                    state.glide = exp_dB (80.0f - 72.0f * ccValueNormalized); if (state.unisonActive) { if (state.glideFinal == state.glideOut) state.glideInc = 0.0f; else if (state.glideFinal > state.glideOut) state.glideInc = state.glide * tau * controlPeriod; else state.glideInc = -state.glide * tau * controlPeriod; }
                }
            }
            if (glide_ccArmed)
            {
                state.glide = exp_dB (80.0f - 72.0f * ccValueNormalized); if (state.unisonActive) { if (state.glideFinal == state.glideOut) state.glideInc = 0.0f; else if (state.glideFinal > state.glideOut) state.glideInc = state.glide * tau * controlPeriod; else state.glideInc = -state.glide * tau * controlPeriod; }
            }
        }
        // --- AmplifierAttack (CC 80) ---
        else if (e.control == 80)
        {
            float ccValueNormalized = e.value;
            if (!amplifierAttack_ccArmed)
            {
                if (abs(ccValueNormalized - amplifierAttack_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    amplifierAttack_ccArmed = true;
                    state.envelopeA_Att = tau * timeToIncrement (-5.0f + 90.7f * ccValueNormalized);
                }
            }
            if (amplifierAttack_ccArmed)
            {
                state.envelopeA_Att = tau * timeToIncrement (-5.0f + 90.7f * ccValueNormalized);
            }
        }
        // --- AmplifierDecay (CC 81) ---
        else if (e.control == 81)
        {
            float ccValueNormalized = e.value;
            if (!amplifierDecay_ccArmed)
            {
                if (abs(ccValueNormalized - amplifierDecay_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    amplifierDecay_ccArmed = true;
                    let factor_cc = timeToIncrement (-3.0f + 85.0f * ccValueNormalized) * tau; state.envelopeA_D_FAC = factor_cc > 1.0f ? 0.0f : (1.0f - factor_cc);
                    for (wrap<numVoices> v_idx) if (voices[v_idx].envelopeA_Stage == 1) voices[v_idx].envelopeA_Fac = state.envelopeA_D_FAC;
                }
            }
            if (amplifierDecay_ccArmed)
            {
                let factor_cc = timeToIncrement (-3.0f + 85.0f * ccValueNormalized) * tau; state.envelopeA_D_FAC = factor_cc > 1.0f ? 0.0f : (1.0f - factor_cc);
                for (wrap<numVoices> v_idx) if (voices[v_idx].envelopeA_Stage == 1) voices[v_idx].envelopeA_Fac = state.envelopeA_D_FAC;
            }
        }
        // --- AmplifierSustain (CC 82) ---
        else if (e.control == 82)
        {
            float ccValueNormalized = e.value;
            if (!amplifierSustain_ccArmed)
            {
                if (abs(ccValueNormalized - amplifierSustain_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    amplifierSustain_ccArmed = true;
                    state.envelopeA_Sus = 0.95f * ccValueNormalized;
                    for (wrap<numVoices> v_idx) { if (voices[v_idx].envelopeA_Stage == 1) { voices[v_idx].envelopeA_Level = (voices[v_idx].envelopeA_Peak - envelopeAOffset) * state.envelopeA_Sus + envelopeAOffset; voices[v_idx].envelopeA_SDif = voices[v_idx].envelopeA_Out - voices[v_idx].envelopeA_Level; } }
                }
            }
            if (amplifierSustain_ccArmed)
            {
                state.envelopeA_Sus = 0.95f * ccValueNormalized;
                for (wrap<numVoices> v_idx) { if (voices[v_idx].envelopeA_Stage == 1) { voices[v_idx].envelopeA_Level = (voices[v_idx].envelopeA_Peak - envelopeAOffset) * state.envelopeA_Sus + envelopeAOffset; voices[v_idx].envelopeA_SDif = voices[v_idx].envelopeA_Out - voices[v_idx].envelopeA_Level; } }
            }
        }
        // --- AmplifierRelease (CC 83) ---
        else if (e.control == 83)
        {
            float ccValueNormalized = e.value;
            if (!amplifierRelease_ccArmed)
            {
                if (abs(ccValueNormalized - amplifierRelease_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    amplifierRelease_ccArmed = true;
                    state.envelopeA_Rel = -10.0f + 92.0f * ccValueNormalized; let factor_cc = timeToIncrement (state.envelopeRelease * state.envelopeA_Rel) * tau; state.envelopeA_R_FAC = factor_cc > 1.0f ? 0.0f : (1.0f - factor_cc);
                    for (wrap<numVoices> v_idx) if (voices[v_idx].envelopeA_Stage == 2) voices[v_idx].envelopeA_Fac = state.envelopeA_R_FAC;
                }
            }
            if (amplifierRelease_ccArmed)
            {
                state.envelopeA_Rel = -10.0f + 92.0f * ccValueNormalized; let factor_cc = timeToIncrement (state.envelopeRelease * state.envelopeA_Rel) * tau; state.envelopeA_R_FAC = factor_cc > 1.0f ? 0.0f : (1.0f - factor_cc);
                for (wrap<numVoices> v_idx) if (voices[v_idx].envelopeA_Stage == 2) voices[v_idx].envelopeA_Fac = state.envelopeA_R_FAC;
            }
        }
        // --- Analog (CC 87) ---
        else if (e.control == 87)
        {
            float ccValueNormalized = e.value;
            if (!analog_ccArmed)
            {
                if (abs(ccValueNormalized - analog_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    analog_ccArmed = true;
                    // Logic from Analog event
                    let tune_cc = ccValueNormalized > 0.0f ? exp_E (5.0f * ccValueNormalized) * 0.19205f : 0.0f; var seed_cc = 1234567890;
                    for (wrap<numVoices> v_idx) { /* ... voice rnd updates ... */
                        var Feedback_cc = (seed_cc ^ (seed_cc >> 5) ^ (seed_cc >> 13)) << 31; seed_cc >>= 1; seed_cc |= Feedback_cc; voices[v_idx].oscillatorA_Rnd = 0.01f * tune_cc * (-1.0f + (3.0518e-5f * float (seed_cc & 65535))); voices[v_idx].oscillatorA_Tune = state.oscillatorA_Freq + voices[v_idx].oscillatorA_Rnd + state.tune;
                        Feedback_cc = (seed_cc ^ (seed_cc >> 5) ^ (seed_cc >> 13)) << 31; seed_cc >>= 1; seed_cc |= Feedback_cc; voices[v_idx].oscillatorB_Rnd = 0.01f * tune_cc * (-1.0f + (3.0518e-5f * float (seed_cc & 65535))); voices[v_idx].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v_idx].oscillatorB_Rnd + state.tune;
                        Feedback_cc = (seed_cc ^ (seed_cc >> 5) ^ (seed_cc >> 13)) << 31; seed_cc >>= 1; seed_cc |= Feedback_cc; voices[v_idx].filter_RND = 0.5f * tune_cc * (-1.0f + (3.0518e-5f * float (seed_cc & 65535)));
                        Feedback_cc = (seed_cc ^ (seed_cc >> 5) ^ (seed_cc >> 13)) << 31; seed_cc >>= 1; seed_cc |= Feedback_cc; voices[v_idx].polymodEnvRnd = 1.0f + 0.1f * tune_cc * (-1.0f + (3.0518e-5f * float (seed_cc & 65535)));
                        Feedback_cc = (seed_cc ^ (seed_cc >> 5) ^ (seed_cc >> 13)) << 31; seed_cc >>= 1; seed_cc |= Feedback_cc; if (tune_cc != 0.0f) voices[v_idx].unisonRnd = 0.035f * tune_cc * (-1.0f + (3.0518e-5f * float (seed_cc & 65535))); else voices[v_idx].unisonRnd = 0.035f * 2.0f / float (activeVoices) * (bool (v_idx & 1) ? ((float(v_idx) + 1.0f) / 2.0f) : -(float(v_idx) / 2.0f));
                    } smoothValue(); updatePitch();
                }
            }
            if (analog_ccArmed)
            {
                // Logic from Analog event
                let tune_cc = ccValueNormalized > 0.0f ? exp_E (5.0f * ccValueNormalized) * 0.19205f : 0.0f; var seed_cc = 1234567890;
                for (wrap<numVoices> v_idx) { /* ... voice rnd updates ... */
                    var Feedback_cc = (seed_cc ^ (seed_cc >> 5) ^ (seed_cc >> 13)) << 31; seed_cc >>= 1; seed_cc |= Feedback_cc; voices[v_idx].oscillatorA_Rnd = 0.01f * tune_cc * (-1.0f + (3.0518e-5f * float (seed_cc & 65535))); voices[v_idx].oscillatorA_Tune = state.oscillatorA_Freq + voices[v_idx].oscillatorA_Rnd + state.tune;
                    Feedback_cc = (seed_cc ^ (seed_cc >> 5) ^ (seed_cc >> 13)) << 31; seed_cc >>= 1; seed_cc |= Feedback_cc; voices[v_idx].oscillatorB_Rnd = 0.01f * tune_cc * (-1.0f + (3.0518e-5f * float (seed_cc & 65535))); voices[v_idx].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v_idx].oscillatorB_Rnd + state.tune;
                    Feedback_cc = (seed_cc ^ (seed_cc >> 5) ^ (seed_cc >> 13)) << 31; seed_cc >>= 1; seed_cc |= Feedback_cc; voices[v_idx].filter_RND = 0.5f * tune_cc * (-1.0f + (3.0518e-5f * float (seed_cc & 65535)));
                    Feedback_cc = (seed_cc ^ (seed_cc >> 5) ^ (seed_cc >> 13)) << 31; seed_cc >>= 1; seed_cc |= Feedback_cc; voices[v_idx].polymodEnvRnd = 1.0f + 0.1f * tune_cc * (-1.0f + (3.0518e-5f * float (seed_cc & 65535)));
                    Feedback_cc = (seed_cc ^ (seed_cc >> 5) ^ (seed_cc >> 13)) << 31; seed_cc >>= 1; seed_cc |= Feedback_cc; if (tune_cc != 0.0f) voices[v_idx].unisonRnd = 0.035f * tune_cc * (-1.0f + (3.0518e-5f * float (seed_cc & 65535))); else voices[v_idx].unisonRnd = 0.035f * 2.0f / float (activeVoices) * (bool (v_idx & 1) ? ((float(v_idx) + 1.0f) / 2.0f) : -(float(v_idx) / 2.0f));
                } smoothValue(); updatePitch();
            }
        }
        // --- MasterTune (CC 88) ---
        else if (e.control == 88)
        {
            float ccValueNormalized = e.value;
            if (!masterTune_ccArmed)
            {
                if (abs(ccValueNormalized - masterTune_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    masterTune_ccArmed = true;
                    state.masterTune = -0.7f + 1.4f * ccValueNormalized; state.tune = state.masterTune + state.pitchBend;
                    for (wrap<numVoices> v_idx) { voices[v_idx].oscillatorA_Tune = state.oscillatorA_Freq + voices[v_idx].oscillatorA_Rnd + state.tune; voices[v_idx].oscillatorA_F = pitchToFreq (voices[v_idx].pitch + voices[v_idx].oscillatorA_Tune); voices[v_idx].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v_idx].oscillatorB_Rnd + state.tune; voices[v_idx].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v_idx].pitch + voices[v_idx].oscillatorB_Tune); }
                }
            }
            if (masterTune_ccArmed)
            {
                state.masterTune = -0.7f + 1.4f * ccValueNormalized; state.tune = state.masterTune + state.pitchBend;
                for (wrap<numVoices> v_idx) { voices[v_idx].oscillatorA_Tune = state.oscillatorA_Freq + voices[v_idx].oscillatorA_Rnd + state.tune; voices[v_idx].oscillatorA_F = pitchToFreq (voices[v_idx].pitch + voices[v_idx].oscillatorA_Tune); voices[v_idx].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v_idx].oscillatorB_Rnd + state.tune; voices[v_idx].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v_idx].pitch + voices[v_idx].oscillatorB_Tune); }
            }
        }
        // --- Volume (CC 7) ---
        else if (e.control == 7)
        {
            float ccValueNormalized = e.value;
            if (!volume_ccArmed)
            {
                if (abs(ccValueNormalized - volume_lastGuiValueNormalized) <= defaultPickupTolerance)
                {
                    volume_ccArmed = true;
                    state.volumeFinal = masterVolume * ccValueNormalized; smoother();
                }
            }
            if (volume_ccArmed)
            {
                state.volumeFinal = masterVolume * ccValueNormalized; smoother();
            }
        }
        // Pedal controls (no pickup needed for these simple on/off or direct actions)
        else if (e.control == 64) // Sustain Pedal (CC 64)
        {
            pedalSustainActive = (e.value >= 0.5f);
            updateEffectiveSustain();
        }
        else if (e.control == 66) // Sostenuto Pedal (CC 66)
        {
            // ... Sostenuto logic from your previous code ...
            bool previousSostenutoState = pedalSostenutoActive;
            pedalSostenutoActive = (e.value >= 0.5f);

            if (pedalSostenutoActive && !previousSostenutoState)
            {
                for (wrap<numVoices> i_idx = 0; i_idx < activeVoices; ++i_idx)
                {
                    let i = wrap<numVoices>(i_idx);
                    if (voices[i].isActive && voices[i].gate > 0.0f) voices[i].sostenutoHeld = true;
                }
            }
            else if (!pedalSostenutoActive && previousSostenutoState)
            {
                for (wrap<numVoices> i_idx = 0; i_idx < activeVoices; ++i_idx)
                {
                    let i = wrap<numVoices>(i_idx);
                    if (voices[i].sostenutoHeld)
                    {
                        voices[i].sostenutoHeld = false;
                        if (voices[i].gate == 0.0f && !collVoiceSustain[i] && !collVoiceHold[i])
                        {
                            triggerNoteOff(i, 0); releaseVoice(i);
                            if (collVoiceNote[i] > 0) collVoiceNote[i] = noteOffMarker - collVoiceNote[i];
                        }
                    }
                }
            }
        }
        else if (e.control == 41) // OscASaw
        {
            float value = e.value / 127.0f; // As per your example
            state.oscillatorA_SawActive = value != 0 ? 1.0f : 0.0f;
            state.oscillatorA_SawA = state.mixerOscillatorA * state.oscillatorA_SawActive;
        }
        else if (e.control == 41) // OscASaw
        {
            float value = e.value / 127.0f; // As per your example
            state.oscillatorA_SawActive = value != 0 ? 1.0f : 0.0f;
            state.oscillatorA_SawA = state.mixerOscillatorA * state.oscillatorA_SawActive;
        }
        else if (e.control == 22) // PolyModFreqA
        {
            float value = e.value / 127.0f;
            state.oscillatorA_FM_PM = value != 0 ? 0.4f : 0.0f;
        }
        else if (e.control == 23) // PolyModPWA
        {
            float value = e.value / 127.0f;
            state.oscillatorA_PW_PM = value != 0 ? -1.0f : 0.0f;
        }
        else if (e.control == 24) // PolyModFilt
        {
            float value = e.value / 127.0f;
            state.filter_PM = value != 0 ? 3.8f : 0.0f;
        }
        else if (e.control == 42) // OscAPulse
        {
            float value = e.value / 127.0f;
            state.oscillatorA_PulseActive = (value != 0);
        }
        else if (e.control == 44) // OscASync
        {
            float value = e.value / 127.0f;
            state.oscillatorSyncActive = (value > 0.0f); // Matches GUI event condition
        }
        else if (e.control == 113) // DelayINV
        {
            float value = e.value / 127.0f;
            // Logic from event DelayINV (float value)
            state.delayInv = value >= 0.5f ? -1.0f : 1.0f; // Condition from GUI event
            state.delayFeedbackFinal = state.delayFeedbackKnob * state.delayInv * (1.0f - 0.5f * state.delay_HPF_F);
            state.delayWetFinal = state.delayWetKnob * (1.828f - 0.828f * state.delayWetKnob) * 0.5f * state.delayInv;
            smoother();
        }
        else if (e.control == 115) // DelayON
        {
            float value = e.value / 127.0f;
            // Logic from event DelayON (float value)
            if (value < 0.5f) // Condition from GUI event
            {
                state.delayActive = false;
                state.delayWetFinal = 0.0;
                state.delayDryFinal = 1.0;
                smoother();
            }
            else if (! state.delayActive)
            {
                state.delayActive = true;

                state.delayWetFinal = state.delayWetKnob * (1.828f - 0.828f * state.delayWetKnob) * 0.5f * state.delayInv;
                state.delayDryFinal = (1.0f - state.delayWetKnob) * (1.828f - 0.828f * (1.0f - state.delayWetKnob));
                smoother();

                state.delaySum = 0.0;
                state.delay_HPF_LPF = 0.0;
                state.delay_LPF_LPF = 0.0;

                state.delayTime_Inc_1 = 0.0;
                state.delayTime_Inc_2 = 0.0;
                state.delayTime_Inc_3 = 0.0;
                state.delayTime_Inc_4 = 0.0;

                state.delayLFO_Pos_1 = 0.0;
                state.delayLFO_Pos_2 = 0.0;
                state.delayLFO_Pos_3 = 0.0;
                state.delayLFO_Pos_4 = 0.0;

                state.delayTime_Mod_1 = state.delayTime_1;
                state.delayTime_Mod_2 = state.delayTime_2;
                state.delayTime_Mod_3 = state.delayTime_3;
                state.delayTime_Mod_4 = state.delayTime_4;

                delayBuffer = 0;
            }
        }
        else if (e.control == 117) // DelaySync
        {
            float value = e.value / 127.0f;
            // Logic from event DelaySync (float value)
            if (value >= 0.5f) // Condition from GUI event
            {
                state.delaySync = true;
                state.delayRate_1 = state.delayRate;
            }
            else
            {
                state.delaySync = false;

                state.delayRate_1 = state.delayRate * 1.029f;
                state.delayRate_2 = state.delayRate * 0.917f;
                state.delayRate_3 = state.delayRate * 0.972f;
                state.delayRate_4 = state.delayRate * 1.091f;

                state.delayLFO_Pos_2 = state.delayLFO_Pos_1;
                state.delayLFO_Pos_3 = state.delayLFO_Pos_1;
                state.delayLFO_Pos_4 = state.delayLFO_Pos_1;
            }
            computeDelayTimes();
        }
        else if (e.control == 118) // DelayMidi
        {
            float value = e.value / 127.0f;
            // Logic from event DelayMidi (float value)
            if (value >= 0.5f) // Condition from GUI event
            {
                state.delayMIDI = 1;
            }
            else if (state.delayMIDI != 0)
            {
                state.delayMIDI = 0;
                state.delayTime = state.delayTimeRatio / 120.0f;
                computeDelayTimes();
            }
        }
        else if (e.control == 25) // LfoMidiSync
        {
            float value = e.value / 127.0f;
            // Logic from event LfoMidiSync (float value)
            if (value == 0 && state.midiTempo != 0.0f) // Check for actual change if midiTempo was non-zero
                 state.lfoFreq = 2.0f * state.lfoRatio;

            state.midiTempo = value; // This was value != 0 ? 1.0f : 0.0f implicitly in GUI
                                     // but original LfoMidiSync event directly uses value
                                     // so we match that. If value from CC is 0, midiTempo becomes 0.
                                     // If value from CC is >0, midiTempo becomes a small positive number.
                                     // The GUI event uses `value` directly, not `value != 0`.
                                     // So, `state.midiTempo = value;` from GUI becomes `state.midiTempo = (e.value / 127.0f);`
                                     // However, the GUI event input `LfoMidiSync` is defined as boolean in endpoint list,
                                     // so GUI sends 0 or 1.
                                     // The Cmajor event `event LfoMidiSync (float value)` then uses this 0 or 1.
                                     // So, for MIDI, it should be:
            float button_state = (e.value / 127.0f != 0.0f ? 1.0f : 0.0f);
            if (button_state == 0 && state.midiTempo != 0.0f) // If button is now OFF and was ON
                 state.lfoFreq = 2.0f * state.lfoRatio;
            state.midiTempo = button_state; // midiTempo expects 0 or 1 basically
        }
        else if (e.control == 27) // LfoShapeSaw
        {
            float value = (e.value / 127.0f != 0.0f ? 1.0f : 0.0f); // Convert to 0 or 1 for GUI logic
            // Logic from event LfoShapeSaw (float value)
            if (value != 0)
            {
                state.lfoConst = 0.0;
                if (state.lfoShA == 0.0)
                {
                    state.lfoSawA = 0.4f;
                    if (state.lfoPulseA != 0.0 && state.lfoTriangleA != 0.0)
                    {
                        state.lfoShA = 1.0; state.lfoTriangleA = 0.0; state.lfoPulseA = 0.0; state.lfoSawA = 0.0;
                    }
                }
            }
            else
            {
                state.lfoSawA = 0.0;
                if (state.lfoShA != 0.0)
                {
                    state.lfoShA = 0.0; state.lfoPulseA = 0.4f; state.lfoTriangleA = 0.4f;
                }
                else if (state.lfoPulseA == 0.0 && state.lfoTriangleA == 0.0)
                {
                    state.lfoConst = 0.4f;
                }
            }
        }
        else if (e.control == 28) // LfoShapeTri
        {
            float value = (e.value / 127.0f != 0.0f ? 1.0f : 0.0f);
            // Logic from event LfoShapeTri (float value)
            if (value != 0)
            {
                state.lfoConst = 0.0;
                if (state.lfoShA == 0.0)
                {
                    state.lfoTriangleA = 0.4f;
                    if (state.lfoPulseA != 0.0 && state.lfoSawA != 0.0)
                    {
                        state.lfoShA = 1.0; state.lfoTriangleA = 0.0; state.lfoPulseA = 0.0; state.lfoSawA = 0.0;
                    }
                }
            }
            else
            {
                state.lfoTriangleA = 0.0;
                if (state.lfoShA != 0.0)
                {
                    state.lfoShA = 0.0; state.lfoPulseA = 0.4f; state.lfoSawA = 0.4f;
                }
                else if (state.lfoPulseA == 0.0 && state.lfoSawA == 0.0)
                {
                    state.lfoConst = 0.4f;
                }
            }
        }
        else if (e.control == 29) // LfoShapePulse
        {
            float value = (e.value / 127.0f != 0.0f ? 1.0f : 0.0f);
            // Logic from event LfoShapePulse (float value)
            // Note: Original LfoShapePulse event had an extra line `state.lfoPulseA = value != 0 ? 0.4f : 0.0f;` at the end, which seems redundant with the if/else.
            // I'll use the main if/else block.
            if (value != 0)
            {
                state.lfoConst = 0.0;
                if (state.lfoShA == 0.0)
                {
                    state.lfoPulseA = 0.4f;
                    if (state.lfoTriangleA != 0.0 && state.lfoSawA != 0.0)
                    {
                        state.lfoShA = 1.0; state.lfoTriangleA = 0.0; state.lfoPulseA = 0.0; state.lfoSawA = 0.0;
                    }
                }
            }
            else
            {
                state.lfoPulseA = 0.0;
                if (state.lfoShA != 0.0)
                {
                    state.lfoShA = 0.0; state.lfoTriangleA = 0.4f; state.lfoSawA = 0.4f;
                }
                else if (state.lfoTriangleA == 0.0 && state.lfoSawA == 0.0)
                {
                    state.lfoConst = 0.4f;
                }
            }
        }
        else if (e.control == 52) // OscBShapeSaw
        {
            float value = e.value / 127.0f;
            state.oscillatorB_SawA = value != 0 ? 0.5f : 0.0f;
        }
        else if (e.control == 53) // OscBShapeTri
        {
            float value = e.value / 127.0f;
            state.oscillatorB_TriA = (value != 0);
        }
        else if (e.control == 54) // OscBShapePulse
        {
            float value = e.value / 127.0f;
            state.oscillatorB_PulseA = value != 0 ? 1.0f : 0.0f;
        }
        else if (e.control == 56) // OscBSubOsc
        {
            float value = e.value / 127.0f;
            // Logic from event OscBSubOsc (float value)
            state.oscillatorB_LOF = value != 0 ? -91.3f : 0.0f;
            for (wrap<numVoices> v)
            {
                voices[v].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v].oscillatorB_Rnd + state.tune;
                voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune);
            }
        }
        else if (e.control == 57) // OscBKKeyboardTracking
        {
            float value = e.value / 127.0f;
            // Logic from event OscBKKeyboardTracking (float value)
            state.oscillatorB_Keyboard = value != 0 ? 1.0f : 0.0f;
            state.oscillatorB_Pitch = 12.0f + 11.0f - 35.0f * state.oscillatorB_Keyboard
                                     + float (int ( ((2.0f - state.oscillatorB_Keyboard)
                                         * (state.oscillatorB_Freq + 0.4f))));
            for (wrap<numVoices> v)
            {
                voices[v].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v].oscillatorB_Rnd + state.tune;
                voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune);
            }
        }
        else if (e.control == 35) // WheelModulationFreqOscA
        {
            float value = e.value / 127.0f;
            state.oscillatorA_FM_WM = value != 0 ? 0.4f : 0.0f;
        }
        else if (e.control == 36) // WheelModulationFreqOscB
        {
            float value = e.value / 127.0f;
            state.oscillatorB_FM_WM = value != 0 ? 0.4f : 0.0f;
        }
        else if (e.control == 37) // WheelModulationPWA
        {
            float value = e.value / 127.0f;
            state.oscillatorA_PW_WM = value != 0 ? 1.0f : 0.0f;
        }
        else if (e.control == 38) // WheelModulationPWB
        {
            float value = e.value / 127.0f;
            state.oscillatorB_PW_WM = value != 0 ? 1.0f : 0.0f;
        }
        else if (e.control == 39) // WheelModulationFilter
        {
            float value = e.value / 127.0f;
            state.filter_WM = value != 0 ? 60.0f : 0.0f;
        }
        else if (e.control == 59) // Unison
        {
            float value = (e.value / 127.0f != 0.0f ? 1.0f : 0.0f); // Convert to 0 or 1 for GUI logic
            // Logic from event Unison (float value)
            state.unisonActive = value != 0; // GUI event uses value != 0
            if (! state.unisonActive)
            {
                state.glideInc = 0;
                for (wrap<numVoices> v)
                {
                    if (v == activeVoices) break;
                    if (voices[v].noteNumber >= 0)
                    {
                        voices[v].pitch = voices[v].noteNumber;
                        voices[v].oscillatorA_F = pitchToFreq (voices[v].pitch + voices[v].oscillatorA_Tune);
                        voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune);
                    }
                    if (voices[v].gate <= 0)
                    {
                        voices[v].envelopeA_Stage = 2; voices[v].envelopeA_Fac = state.envelopeA_R_FAC; voices[v].envelopeA_Level = envelopeAOffset; voices[v].envelopeA_SDif = voices[v].envelopeA_Out - voices[v].envelopeA_Level;
                        voices[v].envelopeF_Stage = 2; voices[v].envelopeF_Fac = state.envelopeF_R_FAC; voices[v].envelopeF_Level = 0.0; voices[v].envelopeF_SDif = voices[v].envelopeF_Out - voices[v].envelopeF_Level;
                    }
                }
                state.unisonGate = 0;
            }
            else
            {
                state.glideFinal = state.unisonNote;
                if (state.glideFinal == state.glideOut)
                {
                    state.glideInc = 0.0;
                    for (wrap<numVoices> v) { if (v == activeVoices) break; voices[v].pitch = state.glideFinal + voices[v].unisonRnd; voices[v].oscillatorA_F = pitchToFreq (voices[v].pitch + voices[v].oscillatorA_Tune); voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune); }
                }
                else if (state.glideFinal > state.glideOut) { state.glideInc = state.glide * tau * controlPeriod; }
                else { state.glideInc = -state.glide * tau * controlPeriod; }
                if (state.droneActive) { sustainedNotesOff(); noteOn (60, 64, 0.0f); sustainActive = true; noteOff (60, 0); }
            }
        }
        else if (e.control == 85) // Release
        {
            float value = (e.value / 127.0f != 0.0f ? 1.0f : 0.0f);
            // Logic from event Release (float value)
            state.envelopeRelease = value != 0 ? 1.0f : 0.0f; // GUI event uses value != 0
            let factor1 = timeToIncrement (state.envelopeRelease * state.envelopeA_Rel) * tau; state.envelopeA_R_FAC = factor1 > 1.0 ? 0.0f : (1.0f - factor1);
            for (wrap<numVoices> v) if (voices[v].envelopeA_Stage == 2) voices[v].envelopeA_Fac = state.envelopeA_R_FAC;
            let factor2 = timeToIncrement (state.envelopeRelease * state.envelopeF_Rel) * tau; state.envelopeF_R_FAC = factor2 > 1.0 ? 0.0f : (1.0f - factor2);
            for (wrap<numVoices> v) if (voices[v].envelopeF_Stage == 2) voices[v].envelopeF_Fac = state.envelopeF_R_FAC;
        }
        else if (e.control == 86) // Velocity
        {
            float value = e.value / 127.0f;
            // Logic from event Velocity (float value)
            if (value != 0) // GUI event uses value != 0
            { state.velocityFilter = 0.55f; state.velocityAmp = 0.8f; }
            else { state.velocityFilter = 0.0; state.velocityAmp = 0.0; }
        }
        else if (e.control == 30) // Repeat
        {
            float value = e.value / 127.0f;
            state.repeatActive = (value != 0); // GUI event uses value != 0
        }
        else if (e.control == 84) // Drone
        {
            float value = (e.value / 127.0f != 0.0f ? 1.0f : 0.0f); // GUI event uses int(value) != 0
            // Logic from event Drone (float value)
            bool newDroneState = (int (value) != 0); // Matches GUI event's casting for comparison
            if (newDroneState && !state.droneActive)
            {
                state.droneActive = true;
                bool already_playing = false;
                for (wrap<numVoices> v = 0; v < activeVoices; ++v) { if (collVoiceNote[v] > 0 && voices[v].gate > 0) { already_playing = true; break; } }
                if (!already_playing) { noteOn (60, 64, 0.0f); noteOff (60, 0); }
            }
            else if (!newDroneState && state.droneActive) { state.droneActive = false; }
            state.droneActive = newDroneState; // Ensure final state is set
            updateEffectiveSustain();
        }
        else if (e.control == 74) // FilterHPF
        {
            float value = e.value / 127.0f;
            // Logic from event FilterHPF (float value)
            state.filter_HPF = (value > 0); // GUI event uses value > 0
            float Res;
            if (state.filter_Res < 0.25) Res = 2.32f * state.filter_Res;
            else if (state.filter_Res < 0.5) Res = 0.52f * state.filter_Res + 0.45f;
            else if (state.filter_Res < 0.75) Res = 0.92f * state.filter_Res + 0.25f;
            else Res = 0.036f * state.filter_Res + 0.913f;
            state.filter_D = 2.0f - 2.0f * Res;
            if (state.filter_HPF) state.filter_FMAX = 0.5f + 0.0318f * Res * (27.5989f + Res);
            else state.filter_FMAX = 0.7352f + 0.2930f * Res * (1.3075f + Res);
            Res *= 0.8f; state.filterN_D = 2.0f - 2.0f * Res;
            if (state.filter_HPF) state.filterN_FMAX = 0.5f + 0.0318f * Res * (27.5989f + Res);
            else state.filterN_FMAX = 0.7352f + 0.2930f * Res * (1.3075f + Res);
            smoothValue();
        }
        else if (e.control == 79) // FilterInvertEnv
        {
            float value = e.value / 127.0f;
            // Logic from event FilterInvertEnv (float value)
            if (value != 0) state.filterEnvelopeInv = -1.0; // GUI event uses value != 0
            else state.filterEnvelopeInv = 1.0;
            if (state.filterEnvelopeFinal > 0) state.filterEnvelopeFinal = state.filterEnvelopeFinal * state.filterEnvelopeInv;
            else state.filterEnvelopeFinal = -state.filterEnvelopeFinal * state.filterEnvelopeInv;
            smoothValue();
        }
    }


//===GUI EVENTS===

    event FilterVersion (float n)              { filterVersion = n > 0.6f ? 2 : (n < 0.3f ? 0 : 1); }

    event TestTone (float f)
    {
        testToneActive = (f != 0);
    }

    event PolyModFilterEnv (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        let Knob = 0.4f + 4.7f * internalValueNormalized;
        state.polymodEnvelopeF = Knob * Knob - 0.16f;

        polyModFilterEnv_lastGuiValueNormalized = internalValueNormalized;
        polyModFilterEnv_ccArmed = false;
    }

    // --- PolyModOscB ---
    event PolyModOscB (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.polymodOscillatorB = 3.09f * internalValueNormalized;

        polyModOscB_lastGuiValueNormalized = internalValueNormalized;
        polyModOscB_ccArmed = false;
    }

    // --- OscAFreq ---
    event OscAFreq (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.oscillatorA_Freq = float (-24 + int ((0.375f * 127.0f) * internalValueNormalized + 0.4f)) + 12;
        for (wrap<numVoices> v) { voices[v].oscillatorA_Tune = state.oscillatorA_Freq + voices[v].oscillatorA_Rnd + state.tune; voices[v].oscillatorA_F = pitchToFreq (voices[v].pitch + voices[v].oscillatorA_Tune); }

        oscAFreq_lastGuiValueNormalized = internalValueNormalized;
        oscAFreq_ccArmed = false;
    }

    // --- OscAPW ---
    event OscAPW (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.oscillatorA_PW_Final = internalValueNormalized * 2.0f - 1.0f;
        smoothValue();

        oscAPW_lastGuiValueNormalized = internalValueNormalized;
        oscAPW_ccArmed = false;
    }

    // --- MixerOscALevel ---
    event MixerOscALevel (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.mixerOscillatorA_Final = internalValueNormalized;
        smoothValue();

        mixerOscALevel_lastGuiValueNormalized = internalValueNormalized;
        mixerOscALevel_ccArmed = false;
    }

    // --- MixerOscBLevel ---
    event MixerOscBLevel (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.mixerOscillatorB_Final = 2.0f * internalValueNormalized;
        smoothValue();

        mixerOscBLevel_lastGuiValueNormalized = internalValueNormalized;
        mixerOscBLevel_ccArmed = false;
    }

    // --- MixerNoiseLevel ---
    event MixerNoiseLevel (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.mixerNoise = 0.35f * 5.0f * internalValueNormalized;

        mixerNoiseLevel_lastGuiValueNormalized = internalValueNormalized;
        mixerNoiseLevel_ccArmed = false;
    }

    // --- ExternalInputLevel ---
    event ExternalInputLevel (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.mixerExternal = inputVolume * internalValueNormalized;

        externalInputLevel_lastGuiValueNormalized = internalValueNormalized;
        externalInputLevel_ccArmed = false;
    }

    event FilterCutoff (float value) // value is 0-100 from GUI
    {
        let internalValueNormalized = value * 0.01f; // Convert GUI 0-100 to 0-1

        state.filter_Cutoff = -39.0f + float (int (120.0f * internalValueNormalized));
        smoothValue();

        // Store this as the last GUI-set value and disarm the CC
        filterCutoff_lastGuiValueNormalized = internalValueNormalized; // This sets it on load too
        filterCutoff_ccArmed = false; // Always disarm on GUI change
    }

        // Event handler for GUI changes to FilterResonance
    event FilterResonance (float value) // value is 0-100 from GUI
    {
        let internalValueNormalized = value * 0.01f; // Convert GUI 0-100 to 0-1

        // Update synth state
        state.filter_Res = internalValueNormalized;
        // ... (full resonance calculation logic) ...
        float Res;
        if (state.filter_Res < 0.25) Res = 2.32f * state.filter_Res;
        else if (state.filter_Res < 0.5f) Res = 0.52f * state.filter_Res + 0.45f;
        else if (state.filter_Res < 0.75f) Res = 0.92f * state.filter_Res + 0.25f;
        else Res = 0.036f * state.filter_Res + 0.913f;
        state.filter_D = 2.0f - 2.0f * Res;
        state.filter_K = 4.1f * internalValueNormalized;
        if (state.filter_HPF) state.filter_FMAX = 0.5f + 0.0318f * Res * (27.5989f + Res);
        else state.filter_FMAX = 0.7352f + 0.2930f * Res * (1.3075f + Res);
        Res *= 0.8f;
        state.filterN_D = 2.0f - 2.0f * Res;
        if (state.filter_HPF) state.filterN_FMAX = 0.5f + 0.0318f * Res * (27.5989f + Res);
        else state.filterN_FMAX = 0.7352f + 0.2930f * Res * (1.3075f + Res);
        smoothValue();

        // Store this as the last GUI-set value and disarm the CC
        filterResonance_lastGuiValueNormalized = internalValueNormalized;
        filterResonance_ccArmed = false;
    }

    event FilterHPF (float value)
    {
        state.filter_HPF = (value > 0);
        float Res;

        if (state.filter_Res < 0.25)
            Res = 2.32f * state.filter_Res;
        else if (state.filter_Res < 0.5)
            Res = 0.52f * state.filter_Res + 0.45f;
        else if (state.filter_Res < 0.75)
            Res = 0.92f * state.filter_Res + 0.25f;
        else
            Res = 0.036f * state.filter_Res + 0.913f;

        state.filter_D = 2.0f - 2.0f * Res;

        if (state.filter_HPF)
            state.filter_FMAX = 0.5f + 0.0318f * Res * (27.5989f + Res);
        else
            state.filter_FMAX = 0.7352f + 0.2930f * Res * (1.3075f + Res);

        Res *= 0.8f;
        state.filterN_D = 2.0f - 2.0f * Res;

        if (state.filter_HPF)
            state.filterN_FMAX = 0.5f + 0.0318f * Res * (27.5989f + Res);
        else
            state.filterN_FMAX = 0.7352f + 0.2930f * Res * (1.3075f + Res);

        smoothValue();
    }

    // --- FilterEnvAmt ---
    event FilterEnvAmt (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.filterEnvelopeFinal = state.filterEnvelopeInv * 192.0f * internalValueNormalized;
        smoothValue();

        filterEnvAmt_lastGuiValueNormalized = internalValueNormalized;
        filterEnvAmt_ccArmed = false;
    }

    event FilterInvertEnv (float value)
    {
        if (value != 0)
            state.filterEnvelopeInv = -1.0;
        else
            state.filterEnvelopeInv = 1.0;

        if (state.filterEnvelopeFinal > 0)
            state.filterEnvelopeFinal = state.filterEnvelopeFinal * state.filterEnvelopeInv;
        else
            state.filterEnvelopeFinal = -state.filterEnvelopeFinal * state.filterEnvelopeInv;

        smoothValue();
    }

    // --- FilterKeyboardTracking ---
    event FilterKeyboardTracking (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f; // This parameter's event already uses 0-1 for state.filterKeyboardFinal
        state.filterKeyboardFinal = internalValueNormalized;
        smoothValue();

        filterKeyboardTracking_lastGuiValueNormalized = internalValueNormalized;
        filterKeyboardTracking_ccArmed = false;
    }

    // --- FilterAttack ---
    event FilterAttack (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.envelopeF_Att = tau * timeToIncrement (-5.0f + 90.7f * internalValueNormalized);

        filterAttack_lastGuiValueNormalized = internalValueNormalized;
        filterAttack_ccArmed = false;
    }

    // --- FilterDecay ---
    event FilterDecay (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        let factor = timeToIncrement (-3.0f + 85.0f * internalValueNormalized) * tau;
        state.envelopeF_D_FAC = factor > 1.0f ? 0.0f : (1.0f - factor);
        for (wrap<numVoices> v) if (voices[v].envelopeF_Stage == 1) voices[v].envelopeF_Fac = state.envelopeF_D_FAC;

        filterDecay_lastGuiValueNormalized = internalValueNormalized;
        filterDecay_ccArmed = false;
    }

    // --- FilterSustain ---
    event FilterSustain (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.envelopeF_Sus = 0.98f * internalValueNormalized;
        for (wrap<numVoices> v) { if (voices[v].envelopeF_Stage == 1) { voices[v].envelopeF_Level = state.envelopeF_Sus * voices[v].envelopeF_Peak; voices[v].envelopeF_SDif = voices[v].envelopeF_Out - voices[v].envelopeF_Level; } }

        filterSustain_lastGuiValueNormalized = internalValueNormalized;
        filterSustain_ccArmed = false;
    }

    // --- FilterRelease ---
    event FilterRelease (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.envelopeF_Rel = -10.0f + 92.7f * internalValueNormalized;
        let factor = timeToIncrement (state.envelopeRelease * state.envelopeF_Rel) * tau;
        state.envelopeF_R_FAC = factor > 1.0f ? 0.0f : (1.0f - factor);
        for (wrap<numVoices> v) if (voices[v].envelopeF_Stage == 2) voices[v].envelopeF_Fac = state.envelopeF_R_FAC;

        filterRelease_lastGuiValueNormalized = internalValueNormalized;
        filterRelease_ccArmed = false;
    }

    // --- DelayTime ---
    event DelayTime (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        float octave_gui = -8.97f + (1.0f + 8.97f) * internalValueNormalized; int octaveInt_gui = int (floor (octave_gui)); state.delayTimeRatio = 0.001953125f * float(1 << (octaveInt_gui + 9)); state.delayTimeRatio *= 60.0f; if (octave_gui - float(octaveInt_gui) > 0.58f) state.delayTimeRatio *= 1.5f; if (state.delayMIDI == 0.0f) state.delayTime = exp_dB (-60.0f + 60.0f * internalValueNormalized); computeDelayTimes();

        delayTime_lastGuiValueNormalized = internalValueNormalized;
        delayTime_ccArmed = false;
    }

    // --- DelaySpread ---
    event DelaySpread (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.delaySpread = internalValueNormalized;
        computeDelayTimes();

        delaySpread_lastGuiValueNormalized = internalValueNormalized;
        delaySpread_ccArmed = false;
    }

    // --- DelayDepth ---
    event DelayDepth (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.delayDepthKnob = internalValueNormalized > 0.0f ? exp_E (5.0f * internalValueNormalized) * 0.000185f : 0.0f;
        state.delayDepth = state.delayDepthKnob * float (processor.frequency);
        computeDelayTimes();

        delayDepth_lastGuiValueNormalized = internalValueNormalized;
        delayDepth_ccArmed = false;
    }

    // --- DelayRate ---
    event DelayRate (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.delayRate = pitchToFreq (-60.0f + 80.0f * internalValueNormalized);
        if (state.delaySync) { state.delayRate_1 = state.delayRate; }
        else { state.delayRate_1 = state.delayRate * 1.029f; state.delayRate_2 = state.delayRate * 0.917f; state.delayRate_3 = state.delayRate * 0.972f; state.delayRate_4 = state.delayRate * 1.091f; }

        delayRate_lastGuiValueNormalized = internalValueNormalized;
        delayRate_ccArmed = false;
    }

    // --- DelayFeedback ---
    event DelayFeedback (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.delayFeedbackKnob = internalValueNormalized * 0.25f;
        state.delayFeedbackFinal = state.delayFeedbackKnob * state.delayInv * (1.0f - 0.5f * state.delay_HPF_F);
        smoother();

        delayFeedback_lastGuiValueNormalized = internalValueNormalized;
        delayFeedback_ccArmed = false;
    }

    // --- DelayHiCut ---
    event DelayHiCut (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.delay_HPF_F = min (0.99f, pitchToFreq (0.0f + 120.0f * internalValueNormalized) * tauFilter);
        state.delayFeedbackFinal = state.delayFeedbackKnob * state.delayInv * (1.0f - 0.5f * state.delay_HPF_F);
        smoother();

        delayHiCut_lastGuiValueNormalized = internalValueNormalized;
        delayHiCut_ccArmed = false;
    }

    // --- DelayLoCut ---
    event DelayLoCut (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.delay_LPF_F = min (0.99f, pitchToFreq (40.0f + 80.0f * internalValueNormalized) * tauFilter);

        delayLoCut_lastGuiValueNormalized = internalValueNormalized;
        delayLoCut_ccArmed = false;
    }

    // --- DelayWet ---
    event DelayWet (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.delayWetKnob = internalValueNormalized;
        if (state.delayActive) { state.delayWetFinal = state.delayWetKnob * (1.828f - 0.828f * state.delayWetKnob) * 0.5f * state.delayInv; state.delayDryFinal = (1.0f - state.delayWetKnob) * (1.828f - 0.828f * (1.0f - state.delayWetKnob)); smoother(); }

        delayWet_lastGuiValueNormalized = internalValueNormalized;
        delayWet_ccArmed = false;
    }

    // --- LfoFrequency ---
    event LfoFrequency (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        float octave_gui = -5.5f + 9.725f * internalValueNormalized; int octaveInt_gui = int (floor (octave_gui)); state.lfoRatio = 0.015625f * float(1 << (octaveInt_gui + 6)); if (octave_gui - float(octaveInt_gui) > 0.58f) state.lfoRatio *= 1.5f; if (state.midiTempo == 0.0f) state.lfoFreq = pitchToFreq (-92.7f + 116.7f * internalValueNormalized);

        lfoFrequency_lastGuiValueNormalized = internalValueNormalized;
        lfoFrequency_ccArmed = false;
    }

    // --- OscBFreq ---
    event OscBFreq (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.oscillatorB_Freq = 0.375f * 127.0f * internalValueNormalized;
        state.oscillatorB_Pitch = 12.0f + 11.0f - 35.0f * state.oscillatorB_Keyboard + float (int ((2.0f - state.oscillatorB_Keyboard) * (state.oscillatorB_Freq + 0.4f)));
        for (wrap<numVoices> v) { voices[v].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v].oscillatorB_Rnd + state.tune; voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune); }

        oscBFreq_lastGuiValueNormalized = internalValueNormalized;
        oscBFreq_ccArmed = false;
    }

    // --- OscBFreqFine ---
    event OscBFreqFine (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.oscillatorB_Fine = 0.015f + 0.935f * internalValueNormalized;
        for (wrap<numVoices> v) { voices[v].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v].oscillatorB_Rnd + state.tune; voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune); }

        oscBFreqFine_lastGuiValueNormalized = internalValueNormalized;
        oscBFreqFine_ccArmed = false;
    }

    // --- OscBPWAmount ---
    event OscBPWAmount (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.oscillatorB_PW_Final = internalValueNormalized * 2.0f - 1.0f;
        smoothValue();

        oscBPWAmount_lastGuiValueNormalized = internalValueNormalized;
        oscBPWAmount_ccArmed = false;
    }

    // --- WheelModulationLfoNoise ---
    event WheelModulationLfoNoise (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.lfoNoiseMix = internalValueNormalized;

        wheelModulationLfoNoise_lastGuiValueNormalized = internalValueNormalized;
        wheelModulationLfoNoise_ccArmed = false;
    }

    // --- Glide ---
    event Glide (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.glide = exp_dB (80.0f - 72.0f * internalValueNormalized);
        if (state.unisonActive) { if (state.glideFinal == state.glideOut) state.glideInc = 0.0f; else if (state.glideFinal > state.glideOut) state.glideInc = state.glide * tau * controlPeriod; else state.glideInc = -state.glide * tau * controlPeriod; }

        glide_lastGuiValueNormalized = internalValueNormalized;
        glide_ccArmed = false;
    }

    // --- AmplifierAttack ---
    event AmplifierAttack (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.envelopeA_Att = tau * timeToIncrement (-5.0f + 90.7f * internalValueNormalized);

        amplifierAttack_lastGuiValueNormalized = internalValueNormalized;
        amplifierAttack_ccArmed = false;
    }

    // --- AmplifierDecay ---
    event AmplifierDecay (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        let factor = timeToIncrement (-3.0f + 85.0f * internalValueNormalized) * tau;
        state.envelopeA_D_FAC = factor > 1.0f ? 0.0f : (1.0f - factor);
        for (wrap<numVoices> v) if (voices[v].envelopeA_Stage == 1) voices[v].envelopeA_Fac = state.envelopeA_D_FAC;

        amplifierDecay_lastGuiValueNormalized = internalValueNormalized;
        amplifierDecay_ccArmed = false;
    }

    // --- AmplifierSustain ---
    event AmplifierSustain (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.envelopeA_Sus = 0.95f * internalValueNormalized;
        for (wrap<numVoices> v) { if (voices[v].envelopeA_Stage == 1) { voices[v].envelopeA_Level = (voices[v].envelopeA_Peak - envelopeAOffset) * state.envelopeA_Sus + envelopeAOffset; voices[v].envelopeA_SDif = voices[v].envelopeA_Out - voices[v].envelopeA_Level; } }

        amplifierSustain_lastGuiValueNormalized = internalValueNormalized;
        amplifierSustain_ccArmed = false;
    }

    // --- AmplifierRelease ---
    event AmplifierRelease (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.envelopeA_Rel = -10.0f + 92.0f * internalValueNormalized;
        let factor = timeToIncrement (state.envelopeRelease * state.envelopeA_Rel) * tau;
        state.envelopeA_R_FAC = factor > 1.0f ? 0.0f : (1.0f - factor);
        for (wrap<numVoices> v) if (voices[v].envelopeA_Stage == 2) voices[v].envelopeA_Fac = state.envelopeA_R_FAC;

        amplifierRelease_lastGuiValueNormalized = internalValueNormalized;
        amplifierRelease_ccArmed = false;
    }

    // --- Analog ---
    event Analog (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        let tune = internalValueNormalized > 0.0f ? exp_E (5.0f * internalValueNormalized) * 0.19205f : 0.0f;
        var seed = 1234567890;
        for (wrap<numVoices> v) { /* ... voice rnd updates from original Analog event ... */
            var Feedback = (seed ^ (seed >> 5) ^ (seed >> 13)) << 31; seed >>= 1; seed |= Feedback; voices[v].oscillatorA_Rnd = 0.01f * tune * (-1.0f + (3.0518e-5f * float (seed & 65535))); voices[v].oscillatorA_Tune = state.oscillatorA_Freq + voices[v].oscillatorA_Rnd + state.tune;
            Feedback = (seed ^ (seed >> 5) ^ (seed >> 13)) << 31; seed >>= 1; seed |= Feedback; voices[v].oscillatorB_Rnd = 0.01f * tune * (-1.0f + (3.0518e-5f * float (seed & 65535))); voices[v].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v].oscillatorB_Rnd + state.tune;
            Feedback = (seed ^ (seed >> 5) ^ (seed >> 13)) << 31; seed >>= 1; seed |= Feedback; voices[v].filter_RND = 0.5f * tune * (-1.0f + (3.0518e-5f * float (seed & 65535)));
            Feedback = (seed ^ (seed >> 5) ^ (seed >> 13)) << 31; seed >>= 1; seed |= Feedback; voices[v].polymodEnvRnd = 1.0f + 0.1f * tune * (-1.0f + (3.0518e-5f * float (seed & 65535)));
            Feedback = (seed ^ (seed >> 5) ^ (seed >> 13)) << 31; seed >>= 1; seed |= Feedback; if (tune != 0.0f) voices[v].unisonRnd = 0.035f * tune * (-1.0f + (3.0518e-5f * float (seed & 65535))); else voices[v].unisonRnd = 0.035f * 2.0f / float (activeVoices) * (bool (v & 1) ? ((float(v) + 1.0f) / 2.0f) : -(float(v) / 2.0f));
        }
        smoothValue(); updatePitch();

        analog_lastGuiValueNormalized = internalValueNormalized;
        analog_ccArmed = false;
    }

    // --- MasterTune ---
    event MasterTune (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.masterTune = -0.7f + 1.4f * internalValueNormalized;
        state.tune = state.masterTune + state.pitchBend;
        for (wrap<numVoices> v) { voices[v].oscillatorA_Tune = state.oscillatorA_Freq + voices[v].oscillatorA_Rnd + state.tune; voices[v].oscillatorA_F = pitchToFreq (voices[v].pitch + voices[v].oscillatorA_Tune); voices[v].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v].oscillatorB_Rnd + state.tune; voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune); }

        masterTune_lastGuiValueNormalized = internalValueNormalized;
        masterTune_ccArmed = false;
    }

    // --- Volume ---
    event Volume (float guiValue) // guiValue 0-100
    {
        let internalValueNormalized = guiValue * 0.01f;
        state.volumeFinal = masterVolume * internalValueNormalized;
        smoother();

        volume_lastGuiValueNormalized = internalValueNormalized;
        volume_ccArmed = false;
    }

    event PolyModFreqA (float value)
    {
        state.oscillatorA_FM_PM = value != 0 ? 0.4f : 0.0f;
    }

    event PolyModPWA (float value)
    {
        state.oscillatorA_PW_PM = value != 0 ? -1.0f : 0.0f; // now -1 because osc phase now goes over 2 units
    }

    event PolyModFilt (float value)
    {
        state.filter_PM = value != 0 ? 3.8f : 0.0f;
    }

    event OscASaw (float value)
    {
        state.oscillatorA_SawActive = value != 0 ? 1.0f : 0.0f;
        state.oscillatorA_SawA = state.mixerOscillatorA * state.oscillatorA_SawActive;
    }

    event OscAPulse (float value)
    {
        state.oscillatorA_PulseActive = (value != 0);
    }

    event OscASync (float value)
    {
        state.oscillatorSyncActive = (value > 0.0f);
    }

    event LfoMidiSync (float value)
    {
        if (value == 0 && state.midiTempo)
            state.lfoFreq = 2.0f * state.lfoRatio;

        state.midiTempo = value;
    }

    event LfoShapeSaw (float value)
    {
        if (value != 0) // button on
        {
            state.lfoConst = 0.0;

            if (state.lfoShA == 0.0)
            {
                state.lfoSawA = 0.4f;

                if (state.lfoPulseA != 0.0 && state.lfoTriangleA != 0.0) // all three buttons now on?
                {
                    state.lfoShA = 1.0;  // switch on Sample&Hold mode
                    state.lfoTriangleA = 0.0; // switch off all LFO waveforms
                    state.lfoPulseA = 0.0;
                    state.lfoSawA = 0.0;
                }
            }
        }
        else // button off
        {
            state.lfoSawA = 0.0;

            if (state.lfoShA != 0.0) // currently in Sample&Hold mode
            {
                state.lfoShA = 0.0;    // switch off Sample&Hold mode
                state.lfoPulseA = 0.4f; // switch other LFO waveforms back on
                state.lfoTriangleA = 0.4f;
            }
            else if (state.lfoPulseA == 0.0 && state.lfoTriangleA == 0.0) // all switches now off ?
            {
                state.lfoConst = 0.4f;
            }
        }
    }

    event LfoShapeTri (float value)
    {
        if (value != 0) // button on
        {
            state.lfoConst = 0.0;

            if (state.lfoShA == 0.0)
            {
                state.lfoTriangleA = 0.4f;

                if (state.lfoPulseA != 0.0 && state.lfoSawA != 0.0) // all three buttons now on?
                {
                    state.lfoShA = 1.0;  // switch on Sample&Hold mode
                    state.lfoTriangleA = 0.0; // switch off all LFO waveforms
                    state.lfoPulseA = 0.0;
                    state.lfoSawA = 0.0;
                }
            }
        }
        else // button off
        {
            state.lfoTriangleA = 0.0;

            if (state.lfoShA != 0.0) // currently in Sample&Hold mode
            {
                state.lfoShA = 0.0;    // switch off Sample&Hold mode
                state.lfoPulseA = 0.4f; // switch other LFO waveforms back on
                state.lfoSawA = 0.4f;
            }
            else if (state.lfoPulseA == 0.0 && state.lfoSawA == 0.0) // all switches now off?
            {
                state.lfoConst = 0.4f;
            }
        }
    }

    event LfoShapePulse (float value)
    {
        if (value != 0) // button on
        {
            state.lfoConst = 0.0;

            if (state.lfoShA == 0.0)
            {
                state.lfoPulseA = 0.4f;

                if (state.lfoTriangleA != 0.0 && state.lfoSawA != 0.0) // all three buttons now on?
                {
                    state.lfoShA = 1.0;  // switch on Sample&Hold mode
                    state.lfoTriangleA = 0.0; // switch off all LFO waveforms
                    state.lfoPulseA = 0.0;
                    state.lfoSawA = 0.0;
                }
            }
        }
        else // button off
        {
            state.lfoPulseA = 0.0;

            if (state.lfoShA != 0.0) // currently in Sample&Hold mode
            {
                state.lfoShA = 0.0;  // switch off Sample&Hold mode
                state.lfoTriangleA = 0.4f; // switch other LFO waveforms back on
                state.lfoSawA = 0.4f;
            }
            else if (state.lfoTriangleA == 0.0 && state.lfoSawA == 0.0) // all switches now off ?
            {
                state.lfoConst = 0.4f;
            }
        }

        state.lfoPulseA = value != 0 ? 0.4f : 0.0f;
    }

    event OscBShapeSaw (float value)
    {
        state.oscillatorB_SawA = value != 0 ? 0.5f : 0.0f; // now 0.5 because osc phase now goes over 2 units
    }

    event OscBShapeTri (float value)
    {
        state.oscillatorB_TriA = (value != 0);
    }

    event OscBShapePulse (float value)
    {
        state.oscillatorB_PulseA = value != 0 ? 1.0f : 0.0f;
    }

    event OscBSubOsc (float value)
    {
        state.oscillatorB_LOF = value != 0 ? -91.3f : 0.0f;

        for (wrap<numVoices> v)
        {
            voices[v].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v].oscillatorB_Rnd + state.tune;
            voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune);
        }
    }

    event OscBKKeyboardTracking (float value)
    {
        state.oscillatorB_Keyboard = value != 0 ? 1.0f : 0.0f;

        state.oscillatorB_Pitch = 12.0f + 11.0f - 35.0f * state.oscillatorB_Keyboard
                                 + float (int ( ((2.0f - state.oscillatorB_Keyboard)
                                     * (state.oscillatorB_Freq + 0.4f)))); // add 12 because osc phase now goes over 2 units

        for (wrap<numVoices> v)
        {
            voices[v].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v].oscillatorB_Rnd + state.tune;
            voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune);
        }
    }

    event WheelModulationFreqOscA (float value)
    {
        state.oscillatorA_FM_WM = value != 0 ? 0.4f : 0.0f;
    }

    event WheelModulationFreqOscB (float value)
    {
        state.oscillatorB_FM_WM = value != 0 ? 0.4f : 0.0f;
    }

    event WheelModulationPWA (float value)
    {
        state.oscillatorA_PW_WM = value != 0 ? 1.0f : 0.0f; // now 1 because osc phase now goes over 2 units
    }

    event WheelModulationPWB (float value)
    {
        state.oscillatorB_PW_WM = value != 0 ? 1.0f : 0.0f; // now 1 because osc phase now goes over 2 units
    }

    event WheelModulationFilter (float value)
    {
        state.filter_WM = value != 0 ? 60.0f : 0.0f;
    }

    event Unison (float value)
    {
        state.unisonActive = value != 0;

        if (! state.unisonActive)
        {
            state.glideInc = 0;

            for (wrap<numVoices> v)
            {
                if (voices[v].noteNumber >= 0)
                {
                    voices[v].pitch = voices[v].noteNumber;
                    voices[v].oscillatorA_F = pitchToFreq (voices[v].pitch + voices[v].oscillatorA_Tune);
                    voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune);
                }

                if (voices[v].gate <= 0)
                {
                    voices[v].envelopeA_Stage = 2;
                    voices[v].envelopeA_Fac = state.envelopeA_R_FAC;
                    voices[v].envelopeA_Level = envelopeAOffset;
                    voices[v].envelopeA_SDif = voices[v].envelopeA_Out - voices[v].envelopeA_Level;

                    voices[v].envelopeF_Stage = 2;
                    voices[v].envelopeF_Fac = state.envelopeF_R_FAC;
                    voices[v].envelopeF_Level = 0.0;
                    voices[v].envelopeF_SDif = voices[v].envelopeF_Out - voices[v].envelopeF_Level;
                }
            }

            state.unisonGate = 0;
        }
        else // Unison on
        {
            state.glideFinal = state.unisonNote;

            if (state.glideFinal == state.glideOut)
            {
                state.glideInc = 0.0;

                for (wrap<numVoices> v)
                {
                    if (v == activeVoices)
                        break;

                    voices[v].pitch = state.glideFinal + voices[v].unisonRnd;

                    voices[v].oscillatorA_F = pitchToFreq (voices[v].pitch + voices[v].oscillatorA_Tune);
                    voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune);
                }
            }
            else if (state.glideFinal > state.glideOut)
            {
                state.glideInc = state.glide * tau * controlPeriod;
            }
            else
            {
                state.glideInc = -state.glide * tau * controlPeriod;
            }

            if (state.droneActive)
            {
                sustainedNotesOff();
                noteOn (60, 64, 0.0f);
                sustainActive = true;
                noteOff (60, 0);
            }
        }
    }

    event Release (float value)
    {
        state.envelopeRelease = value != 0 ? 1.0f : 0.0f;

        let factor1 = timeToIncrement (state.envelopeRelease * state.envelopeA_Rel) * tau;
        state.envelopeA_R_FAC = factor1 > 1.0 ? 0.0f : (1.0f - factor1);

        for (wrap<numVoices> v)
            if (voices[v].envelopeA_Stage == 2) // Release Stage
                voices[v].envelopeA_Fac = state.envelopeA_R_FAC;

        let factor2 = timeToIncrement (state.envelopeRelease * state.envelopeF_Rel) * tau;

        state.envelopeF_R_FAC = factor2 > 1.0 ? 0.0f : (1.0f - factor2);

        for (wrap<numVoices> v)
            if (voices[v].envelopeF_Stage == 2) // Release Stage
                voices[v].envelopeF_Fac = state.envelopeF_R_FAC;
    }

    event Velocity (float value)
    {
        if (value != 0)
        {
            state.velocityFilter = 0.55f;
            state.velocityAmp = 0.8f;
        }
        else
        {
            state.velocityFilter = 0.0;
            state.velocityAmp = 0.0;
        }
    }

    event Repeat (float value)
    {
        state.repeatActive = (value != 0);
    }

    event Drone (float value)
    {
        bool newDroneState = (int (value) != 0);

        if (newDroneState && !state.droneActive) // Drone is turning ON
        {
            state.droneActive = true; // Set new state
            // updateEffectiveSustain will be called after this block, ensuring sustainActive is true
            // before noteOff if drone is on.

            bool already_playing = false;
            for (wrap<numVoices> v = 0; v < activeVoices; ++v)
            {
                if (collVoiceNote[v] > 0 && voices[v].gate > 0) // A more robust check for "actively playing"
                {
                    already_playing = true;
                    break;
                }
            }

            if (!already_playing)
            {
                // The subsequent call to updateEffectiveSustain() will ensure
                // sustainActive is true before noteOff is called, if droneActive is true.
                noteOn (60, 64, 0.0f);
                noteOff (60, 0); // This noteOff will use the correct sustainActive value
            }
        }
        else if (!newDroneState && state.droneActive) // Drone is turning OFF
        {
            state.droneActive = false; // Set new state
            // updateEffectiveSustain will be called after this block.
            // If pedal is also off, sustainedNotesOff() will be triggered.
        }
        // If drone state didn't change but value was resent, still set it.
        state.droneActive = newDroneState;

        updateEffectiveSustain();
    }

    event ModWheel (float value)
    {
        setModWheel (value * 0.01f);
    }

    event PitchBend (float value)
    {
        setPitchBend (value * 0.01f);
    }

    void setPitchBend (float value)
    {
        state.pitchBend = 4.0f * (value - 0.5f); // -2 to 2

        state.tune = state.masterTune + state.pitchBend;

        for (wrap<numVoices> v)
        {
            voices[v].oscillatorA_Tune = state.oscillatorA_Freq + voices[v].oscillatorA_Rnd + state.tune;
            voices[v].oscillatorA_F = pitchToFreq (voices[v].pitch + voices[v].oscillatorA_Tune);

            voices[v].oscillatorB_Tune = state.oscillatorB_LOF + state.oscillatorB_Pitch + state.oscillatorB_Fine + voices[v].oscillatorB_Rnd + state.tune;
            voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune);
        }
    }

    void setModWheel (float value)
    {
        state.modulationWheel = value * 5; // 0 to 5 (5/127)
    }


    event DelayINV (float value)
    {
        state.delayInv = value >= 0.5 ? -1.0f : 1.0f;
        state.delayFeedbackFinal = state.delayFeedbackKnob * state.delayInv * (1.0f - 0.5f * state.delay_HPF_F);
        state.delayWetFinal = state.delayWetKnob * (1.828f - 0.828f * state.delayWetKnob) * 0.5f * state.delayInv;
        smoother();
    }

    event DelayON (float value)
    {
        if (value < 0.5)
        {
            state.delayActive = false;
            state.delayWetFinal = 0.0;
            state.delayDryFinal = 1.0;
            smoother();
        }
        else if (! state.delayActive)
        {
            state.delayActive = true;

            state.delayWetFinal = state.delayWetKnob * (1.828f - 0.828f * state.delayWetKnob) * 0.5f * state.delayInv;
            state.delayDryFinal = (1.0f - state.delayWetKnob) * (1.828f - 0.828f * (1.0f - state.delayWetKnob));
            smoother();

            state.delaySum = 0.0;
            state.delay_HPF_LPF = 0.0;
            state.delay_LPF_LPF = 0.0;

            state.delayTime_Inc_1 = 0.0;
            state.delayTime_Inc_2 = 0.0;
            state.delayTime_Inc_3 = 0.0;
            state.delayTime_Inc_4 = 0.0;

            state.delayLFO_Pos_1 = 0.0;
            state.delayLFO_Pos_2 = 0.0;
            state.delayLFO_Pos_3 = 0.0;
            state.delayLFO_Pos_4 = 0.0;

            state.delayTime_Mod_1 = state.delayTime_1;
            state.delayTime_Mod_2 = state.delayTime_2;
            state.delayTime_Mod_3 = state.delayTime_3;
            state.delayTime_Mod_4 = state.delayTime_4;

            delayBuffer = 0;
        }
    }

    event DelaySync (float value)
    {
        if (value >= 0.5)
        {
            state.delaySync = true;
            state.delayRate_1 = state.delayRate; // only rate1 used in sync mode
        }
        else
        {
            state.delaySync = false;

            state.delayRate_1 = state.delayRate * 1.029f; // +0.5 semitones
            state.delayRate_2 = state.delayRate * 0.917f; // -1.5 semitones
            state.delayRate_3 = state.delayRate * 0.972f; // -0.5 semitones
            state.delayRate_4 = state.delayRate * 1.091f; // -1.5 semitones

            state.delayLFO_Pos_2 = state.delayLFO_Pos_1; // set all LFOs to same phase, will drift apart
            state.delayLFO_Pos_3 = state.delayLFO_Pos_1;
            state.delayLFO_Pos_4 = state.delayLFO_Pos_1;
        }

        computeDelayTimes();
    }

    event DelayMidi (float value)
    {
        if (value >= 0.5)
        {
            state.delayMIDI = 1;
        }
        else if (state.delayMIDI != 0) // switching MIDI Sync off ?
        {
            state.delayMIDI = 0;
            state.delayTime = state.delayTimeRatio / 120.0f; // fudge: Time bleibt noch quantisiert, aber bei 120BPM
            computeDelayTimes();
        }
    }

    event ActiveVoices (float value)
    {
        let v = wrap<numVoices + 1> (value);

        if (activeVoices != v)
        {
            activeVoices = v;
            allSoundOff();
        }
    }

    //==============================================================================
    //==============================================================================
    //==============================================================================
    void smoothValue()
    {
        state.knobSmoothingCounter = knobSmoothingTime;
        float factor = 1.0f / knobSmoothingTime;

        state.mixerOscillatorA_Inc  = undenormalise ((state.mixerOscillatorA_Final - state.mixerOscillatorA) * factor);
        state.mixerOscillatorB_Inc  = undenormalise ((state.mixerOscillatorB_Final - state.mixerOscillatorB) * factor);
        state.oscillatorA_PW_Inc    = undenormalise ((state.oscillatorA_PW_Final - state.oscillatorA_PW) * factor);
        state.oscillatorB_PW_Inc    = undenormalise ((state.oscillatorB_PW_Final - state.oscillatorB_PW) * factor);
        state.filter_EnvInc         = undenormalise ((state.filterEnvelopeFinal - state.filter_Env) * factor);
        state.filter_KeyboardInc    = undenormalise ((state.filterKeyboardFinal - state.filter_Keyboard) * factor);

        let final = 35.0f * (1.0f - state.filterKeyboardFinal) + state.filter_Cutoff + 4.5f * state.filter_Res;
        state.filter_EventInc = undenormalise ((final - state.filter_Event) * (1.0f / (knobSmoothingTime)));
    }

    void smoother()
    {
        state.smootherCount = int (0.02 * processor.frequency); // transition in 20ms
        float factor = 1.0f / state.smootherCount;

        state.volumeInc        = undenormalise ((state.volumeFinal - state.volumeSmooth) * factor);
        state.delayWetInc      = undenormalise ((state.delayWetFinal - state.delayWetSmooth) * factor);
        state.delayDryInc      = undenormalise ((state.delayDryFinal - state.delayDrySmooth) * factor);
        state.delayFeedbackInc = undenormalise ((state.delayFeedbackFinal - state.delayFeedbackSmooth) * factor);
    }

    void sustainedNotesOff()
    {
        sustainActive = false; // This is correct, as this function is called when effective sustain ends.

        for (wrap<numVoices> i = 0; i < activeVoices; ++i) // Ensure loop iterates correctly up to activeVoices
        {
            // if (i == activeVoices) break; // This break is good with `for (wrap<numVoices> i)`

            if (collVoiceSustain[i] && (! collVoiceHold[i]))
            {
                collVoiceSustain[i] = false;
                triggerNoteOff (i, 0);
                releaseVoice (i);
                // Ensure collVoiceNote is marked appropriately to avoid retriggering issues.
                // The original noteOffMarker - note seems to be a way to mark it as "just released".
                collVoiceNote[i] = noteOffMarker - collVoiceNote[i];
            }
        }
    }

    bool triggerNoteOn (wrap<numVoices> voice, int vel, float Detune) // |K< 03.12.99
    {
        let notePitch = collVoiceNote[voice];

        voices[voice].noteNumber = float (notePitch);

        let scaledPitch = voices[voice].noteNumber + Detune;

        if (state.unisonActive)
        {
            state.unisonNote = float (notePitch);
            state.glideFinal = scaledPitch;

            if (state.glideFinal == state.glideOut)
            {
                state.glideInc = 0.0;

                for (wrap<numVoices> v)
                {
                    if (v == activeVoices)
                        break;

                    voices[v].pitch = state.glideFinal + voices[v].unisonRnd;

                    voices[v].oscillatorA_F = pitchToFreq (voices[v].pitch + voices[v].oscillatorA_Tune);
                    voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune);
                }
            }
            else if (state.glideFinal > state.glideOut)
            {
                state.glideInc = state.glide * tau * controlPeriod;
            }
            else
            {
                state.glideInc = -state.glide * tau * controlPeriod;
            }

            state.unisonGate = 1;

            int numActiveVoices;

            for (wrap<numVoices> v)
            {
                if (v == activeVoices)
                    break;

                if (voices[v].gate > 0.0)
                    ++numActiveVoices;
            }

            if (state.repeatActive)
            {
                if (state.midiTempo == 0 && numActiveVoices == 0)
                    state.lfoPhase = 1.0; // key sync LFO, when not synced to song tempo
            }
            else // only trigger when Repeat is off, otherwise triggering will happen from LFO
            {
                if (numActiveVoices == 0)
                {
                    let peakA = 0.5f + state.velocityAmp * (vel * 0.0078125f - 0.5f);
                    let peakF = 0.5f + state.velocityFilter * (vel * 0.0078125f - 0.5f);

                    for (wrap<numVoices> v)
                    {
                        if (v == activeVoices)
                            break;

                        // Amplitude Envelope Gate On
                        voices[v].isActive = true;

                        if (voices[v].envelopeA_Out < 0.0)
                            voices[v].envelopeA_Out = 0.0;

                        if (voices[v].envelopeA_Out > peakA)
                        {
                            voices[v].envelopeA_Peak = voices[v].envelopeA_Out;
                            voices[v].envelopeA_Stage = 1;
                            voices[v].envelopeA_Fac = state.envelopeA_D_FAC;
                            voices[v].envelopeA_Level = (voices[v].envelopeA_Peak - envelopeAOffset) * state.envelopeA_Sus + envelopeAOffset; // Sustain-Level als Teil des Peaklevels
                            voices[v].envelopeA_SDif = voices[v].envelopeA_Peak - voices[v].envelopeA_Level;
                        }
                        else
                        {
                            voices[v].envelopeA_Inc = peakA * state.envelopeA_Att;
                            voices[v].envelopeA_Peak = peakA;
                            voices[v].envelopeA_Stage = 0;
                        }

                        // Filter Envelope Gate On
                        if (voices[v].envelopeF_Out > peakF)
                        {
                            voices[v].envelopeF_Peak = voices[v].envelopeF_Out;
                            voices[v].envelopeF_Stage = 1;
                            voices[v].envelopeF_Fac = state.envelopeF_D_FAC;
                            voices[v].envelopeF_Level = voices[v].envelopeF_Peak * state.envelopeF_Sus;
                            voices[v].envelopeF_SDif = voices[v].envelopeF_Out - voices[v].envelopeF_Level;
                        }
                        else
                        {
                            voices[v].envelopeF_Inc = peakF * state.envelopeF_Att;
                            voices[v].envelopeF_Peak = peakF;
                            voices[v].envelopeF_Stage = 0;
                            voices[v].envelopeF_SDif = 1;
                        }
                    }
                }
                else // already playing but change in envelope amplitude by velocity is possible
                {
                    let peakA = 0.5f + state.velocityAmp * (vel * 0.0078125f - 0.5f);
                    let peakF = 0.5f + state.velocityFilter * (vel * 0.0078125f - 0.5f);

                    for (wrap<numVoices> v)
                    {
                        if (v == activeVoices)
                            break;

                        voices[v].envelopeA_Peak = peakA;

                        if (voices[v].envelopeA_Stage == 0 && voices[v].envelopeA_Out < peakA) // still in attack
                        {
                            voices[v].envelopeA_Inc = peakA * state.envelopeA_Att; // Attack-Increment
                        }
                        else // in decay
                        {
                            voices[v].envelopeA_Stage = 1;
                            voices[v].envelopeA_Fac = state.envelopeA_D_FAC;
                            voices[v].envelopeA_Level = (voices[v].envelopeA_Peak - envelopeAOffset) * state.envelopeA_Sus + envelopeAOffset; // Sustain-Level als Teil des Peaklevels
                            voices[v].envelopeA_SDif = voices[v].envelopeA_Out - voices[v].envelopeA_Level;
                        }

                        voices[v].envelopeF_Peak = peakF;

                        if (voices[v].envelopeF_Stage == 0 && voices[v].envelopeF_Out < peakF) // still in attack
                        {
                            voices[v].envelopeF_Inc = peakF * state.envelopeF_Att; // Attack-Increment
                            voices[v].envelopeF_SDif = 1;
                        }
                        else
                        {
                            voices[v].envelopeF_Stage = 1;
                            voices[v].envelopeF_Fac = state.envelopeF_D_FAC;
                            voices[v].envelopeF_Level = voices[v].envelopeF_Peak * state.envelopeF_Sus;
                            voices[v].envelopeF_SDif = voices[v].envelopeF_Out - voices[v].envelopeF_Level;
                        }
                    }
                }
            }
        }
        else
        {
            if (state.repeatActive)
            {
                if (state.midiTempo == 0)
                {
                    int numActiveVoices;

                    for (wrap<numVoices> v)
                    {
                        if (v == activeVoices)
                            break;

                        if (voices[v].gate > 0.0)
                            ++numActiveVoices;
                    }

                    if (numActiveVoices == 0)
                        state.lfoPhase = 1.0; // key sync LFO, when not synced to song tempo
                }
            }
            else // only trigger when Repeat is off, otherwise triggering will happen from LFO
            {
                let peakA = 0.5f + state.velocityAmp * (vel * 0.0078125f - 0.5f);
                let peakF = 0.5f + state.velocityFilter * (vel * 0.0078125f - 0.5f);

                // Amplitude Envelope Gate On
                voices[voice].isActive = true;

                if (voices[voice].envelopeA_Out > peakA)
                {
                    voices[voice].envelopeA_Peak = voices[voice].envelopeA_Out;
                    voices[voice].envelopeA_Stage = 1;
                    voices[voice].envelopeA_Fac = state.envelopeA_D_FAC;
                    voices[voice].envelopeA_Level = (voices[voice].envelopeA_Peak - envelopeAOffset) * state.envelopeA_Sus + envelopeAOffset;
                    voices[voice].envelopeA_SDif = voices[voice].envelopeA_Peak - voices[voice].envelopeA_Level;
                }
                else
                {
                    voices[voice].envelopeA_Inc = peakA * state.envelopeA_Att;
                    voices[voice].envelopeA_Peak = peakA;
                    voices[voice].envelopeA_Stage = 0;
                }

                // Filter Envelope Gate On
                if (voices[voice].envelopeF_Out > peakF)
                {
                    voices[voice].envelopeF_Peak = voices[voice].envelopeF_Out;
                    voices[voice].envelopeF_Stage = 1;
                    voices[voice].envelopeF_Fac = state.envelopeF_D_FAC;
                    voices[voice].envelopeF_Level = voices[voice].envelopeF_Peak * state.envelopeF_Sus;
                    voices[voice].envelopeF_SDif = voices[voice].envelopeF_Out - voices[voice].envelopeF_Level;
                }
                else
                {
                    voices[voice].envelopeF_Inc = peakF * state.envelopeF_Att;
                    voices[voice].envelopeF_Peak = peakF;
                    voices[voice].envelopeF_Stage = 0;
                    voices[voice].envelopeF_SDif = 1;
                }
            }

            voices[voice].pitch = scaledPitch;

            voices[voice].oscillatorA_F = pitchToFreq (voices[voice].pitch + voices[voice].oscillatorA_Tune);
            voices[voice].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[voice].pitch + voices[voice].oscillatorB_Tune);

            state.unisonNote = float (notePitch);
        }

        voices[voice].gate = float (vel);
        return true;
    }

    void triggerNoteOff (wrap<numVoices> voice, int vel)
    {
        let notePitch = collVoiceNote[voice];

        voices[voice].noteNumber = float (notePitch);

        if (state.unisonActive)
        {
            if (notePitch != state.unisonNote)
            {
                voices[voice].gate = 0.0;
                return;
            }

            int numActiveVoices = 0;
            float nearestNote = 1000.0;

            for (wrap<numVoices> v)
            {
                if (v == activeVoices)
                    break;

                if (voices[v].gate > 0.0)
                {
                    ++numActiveVoices;

                    let bestDiff = int (notePitch - nearestNote);
                    let currDiff = int (notePitch - voices[v].noteNumber);

                    if (currDiff * currDiff < bestDiff * bestDiff && v != voice)
                        nearestNote = voices[v].noteNumber;
                }
            }

            if (voices[voice].gate > 0.0)
            {
                if (numActiveVoices == 1)
                {
                    for (wrap<numVoices> v)
                    {
                        if (v == activeVoices)
                            break;

                        voices[v].envelopeA_Stage = 2;
                        voices[v].envelopeA_Fac = state.envelopeA_R_FAC;
                        voices[v].envelopeA_Level = envelopeAOffset;
                        voices[v].envelopeA_SDif = voices[v].envelopeA_Out - voices[v].envelopeA_Level;

                        voices[v].envelopeF_Stage = 2;
                        voices[v].envelopeF_Fac = state.envelopeF_R_FAC;
                        voices[v].envelopeF_Level = 0.0;
                        voices[v].envelopeF_SDif = voices[v].envelopeF_Out - voices[v].envelopeF_Level;
                    }

                    state.unisonGate = 0;
                }
                else if (numActiveVoices > 1)
                {
                    lastUnison = int (nearestNote);

                    state.unisonNote = nearestNote;
                    state.glideFinal = state.unisonNote;

                    if (state.glideFinal == state.glideOut)
                    {
                        state.glideInc = 0.0;

                        for (wrap<numVoices> v)
                        {
                            if (v == activeVoices)
                                break;

                            voices[v].pitch = state.glideFinal + voices[v].unisonRnd;

                            voices[v].oscillatorA_F = pitchToFreq (voices[v].pitch + voices[v].oscillatorA_Tune);
                            voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune);
                        }
                    }
                    else if (state.glideFinal > state.glideOut)
                    {
                        state.glideInc = state.glide * tau * controlPeriod;
                    }
                    else
                    {
                        state.glideInc = -state.glide * tau * controlPeriod;
                    }
                }
            }
        }
        else
        {
            voices[voice].envelopeA_Stage = 2;
            voices[voice].envelopeA_Fac = state.envelopeA_R_FAC;
            voices[voice].envelopeA_Level = envelopeAOffset;
            voices[voice].envelopeA_SDif = voices[voice].envelopeA_Out - voices[voice].envelopeA_Level;

            voices[voice].envelopeF_Stage = 2;
            voices[voice].envelopeF_Fac = state.envelopeF_R_FAC;
            voices[voice].envelopeF_Level = 0.0;
            voices[voice].envelopeF_SDif = voices[voice].envelopeF_Out - voices[voice].envelopeF_Level;
        }

        voices[voice].gate = 0.0;
    }

    void releaseVoice (wrap<numVoices> v)
    {
        if (youngestOffVoice == -1)
        {
            insertBefore (wrap<numVoices> (oldestVoice), v);
            oldestVoice = v;
        }
        else
        {
            insertAfter (wrap<numVoices> (youngestOffVoice), v);
        }

        youngestOffVoice = v;
    }

    void allSoundOff()
    {
        for (wrap<numVoices> i)
        {
            voices[i].gate = 0.0;
            voices[i].noteNumber = 255.0;

            voices[i].oscillatorA_Phase = fmod (float (i) * 1.97f, 2.0f) - 1; // almost random phase distribution
            voices[i].oscillatorB_Phase = fmod (float (i) * 1.87f, 2.0f) - 1; // almost random phase distribution

            voices[i].oscillatorA_Saw_AA2 = 0.0;
            voices[i].oscillatorA_Pulse_AA2 = 0.0;
            voices[i].oscillatorB_Saw_AA2 = 0.0;
            voices[i].oscillatorB_Pulse_AA2 = 0.0;

            voices[i].filter_BPF = 0.0;
            voices[i].filter_LPF = 0.0;
            voices[i].filterN_BPF = 0.0;
            voices[i].filterN_LPF = 0.0;

            voices[i].envelopeA_Out = 0.0;
            voices[i].envelopeA_SDif = 0.0;
            voices[i].envelopeA_Level = 0.0;
            voices[i].envelopeF_Out = 0.0;
            voices[i].isActive = false;
            voices[i].sostenutoHeld = false; // SOSTPEDAL: Initialize sostenuto state for voice

            voices[i].filter_Event = state.filter_Event + voices[i].filter_RND;
        }

        state.unisonNote = 36;
        delayBuffer = 0;
        setPitchBend (0.5f);
        initVoiceQueue();
    }

    void noteOn (int note, int vel, float detune)
    {
        int n = allocateVoice (oldestVoice, note);

        if (n < 0)
            return;

        let v = wrap<numVoices> (n);

        collVoiceNote[v] = note;

        if (triggerNoteOn (v, vel, detune))
            if (state.unisonActive)
                lastUnison = note;

        collVoiceSustain[v] = false;
        collVoiceHold[v] = false;
    }

    void noteOff (int note, int vel)
    {
        for (wrap<numVoices> v_idx = 0; v_idx < activeVoices; ++v_idx) // Iterate up to activeVoices
        {
            let v = wrap<numVoices>(v_idx);

            if (collVoiceNote[v] == note) // Find the voice playing this note
            {
                // The physical key is now up. Record this fact for the voice.
                // This is crucial for Sostenuto OFF logic, which checks voices[v].gate.
                voices[v].gate = 0.0f;

                // Check if sustain pedal (CC64) or drone is active.
                // `sustainActive` is `pedalSustainActive (CC64) || state.droneActive`.
                // If sustainActive is true, this note should be marked for sustain if its key is released.
                collVoiceSustain[v] = sustainActive;

                bool needsToStartReleaseEnvelope = true;

                if (collVoiceSustain[v]) // Is the note held by CC64 (damper) or Drone?
                {
                    // Yes, so it should not start release yet.
                    needsToStartReleaseEnvelope = false;
                }
                else if (voices[v].sostenutoHeld) // Is the note held by Sostenuto (CC66)?
                {
                    // Yes, physical key is up (voices[v].gate was set to 0.0f above).
                    // The envelope should continue as if the key is still pressed (i.e., not enter release stage).
                    // Actual release will be triggered when Sostenuto pedal goes OFF (handled in CC66 logic).
                    needsToStartReleaseEnvelope = false;
                }
                else if (collVoiceHold[v]) // Is the note held by an internal mechanism?
                {
                    // Yes, so it should not start release yet.
                    needsToStartReleaseEnvelope = false;
                }

                if (needsToStartReleaseEnvelope)
                {
                    // No pedal or internal hold is active for this note, so start its release phase.
                    triggerNoteOff (v, vel); // Sets envelope stages to release and voices[v].gate to 0.0 (redundantly).
                    releaseVoice (v);        // Manage voice allocation queue.
                    collVoiceNote[v] = noteOffMarker - note; // Mark voice slot state.
                }
                // If needsToStartReleaseEnvelope is false, the note continues sounding without its envelope
                // entering the release phase yet. Its voices[v].gate is 0.0 (physical key up).
                // This is the desired behavior for notes sustained by CC64 or CC66.
                // collVoiceSustain[v] being true will ensure sustainedNotesOff() handles it if CC64/Drone is released.
                // voices[v].sostenutoHeld being true ensures CC66 release logic handles it.
            }
        }
    }

    int allocateVoice (int last, int note)
    {
        for (int v = 0; v < activeVoices; v++)
        {
            if (collVoiceNote.at (v) == note
                 || collVoiceNote.at (v) == noteOffMarker - note)
            {
                let s = v;

                if (s == oldestVoice)
                {
                    oldestVoice = collVoiceNext.at (oldestVoice);

                    if (s == youngestOffVoice)
                        youngestOffVoice = -1;
                }
                else
                {
                    if (s == youngestOffVoice)
                        youngestOffVoice = collVoicePrev.at (youngestOffVoice);
                }

                insertBefore (wrap<numVoices> (last), wrap<numVoices> (s));
                return s;
            }
        }

        if (youngestOffVoice >= 0)
        {
            let s = wrap<numVoices> (oldestVoice);
            oldestVoice = collVoiceNext.at (oldestVoice);

            if (s == youngestOffVoice)
               youngestOffVoice = -1;

            insertBefore (wrap<numVoices> (last), wrap<numVoices> (s));
            return s;
        }

        var s = collVoicePrev.at (last);
        var v = s;
        bool foundOldest;

        while (! foundOldest)
        {
            s = v;
            v = collVoicePrev.at (v);
            foundOldest = (v == collVoicePrev.at (oldestVoice));
        }

        if (s == oldestVoice)
            oldestVoice = collVoiceNext.at (oldestVoice);

        insertBefore (wrap<numVoices> (last), wrap<numVoices> (s));
        return s;
    }

    void updatePitch()
    {
        if (state.unisonActive)
        {
            state.glideFinal = state.unisonNote;

            if (state.glideFinal == state.glideOut)
            {
                state.glideInc = 0.0;

                for (wrap<numVoices> v)
                {
                    if (v == activeVoices)
                        break;

                    voices[v].pitch = state.glideFinal + voices[v].unisonRnd;

                    voices[v].oscillatorA_F = pitchToFreq (voices[v].pitch + voices[v].oscillatorA_Tune);
                    voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune);
                }
            }
            else if (state.glideFinal > state.glideOut)
            {
                state.glideInc = state.glide * tau * controlPeriod;
            }
            else
            {
                state.glideInc = -state.glide * tau * controlPeriod;
            }
        }
        else
        {
            for (wrap<numVoices> v)
            {
                if (voices[v].noteNumber >= 0)
                {
                    voices[v].pitch = voices[v].noteNumber;
                    voices[v].oscillatorA_F = pitchToFreq (voices[v].pitch + voices[v].oscillatorA_Tune);
                    voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune);
                }

                voices[v].oscillatorA_F = pitchToFreq (voices[v].pitch + voices[v].oscillatorA_Tune);
                voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune);
            }
        }
    }

    void insertAfter (wrap<numVoices> dest, wrap<numVoices> source)
    {
        if (source == dest)
            return;

        collVoiceNext[wrap<numVoices> (collVoicePrev[source])] = collVoiceNext[source];
        collVoicePrev[wrap<numVoices> (collVoiceNext[source])] = collVoicePrev[source];

        collVoiceNext[source] = collVoiceNext[dest];
        collVoicePrev[source] = dest;
        collVoicePrev[wrap<numVoices> (collVoiceNext[dest])] = source;
        collVoiceNext[dest] = source;
    }

    void insertBefore (wrap<numVoices> dest, wrap<numVoices> source)
    {
        if (source != dest)
            insertAfter (wrap<numVoices> (collVoicePrev[dest]), source);
    }

    void initVoiceQueue()
    {
        for (wrap<numVoices> i)
        {
            collVoiceSustain[i] = false;
            collVoiceHold[i] = false;
            triggerNoteOff (i, 0);
            collVoiceNote[i] = noteOffMarker;
        }

        for (int i = 0; i < numVoices; i++)
        {
            collVoicePrev.at (i) = i - 1;
            collVoiceNext.at (i) = i + 1;
        }

        collVoicePrev[0] = activeVoices - 1;
        collVoiceNext.at (activeVoices - 1) = 0;

               youngestOffVoice = activeVoices - 1;
        oldestVoice = 0;

                if (state.droneActive)
        {
            bool previousSustainStateForDroneInit = sustainActive; // Save current
            sustainActive = true; // Force sustain for this specific drone note init sequence
            noteOn (60, 64, 0.0f);
            noteOff (60, 0);
            sustainActive = previousSustainStateForDroneInit; // Restore
        }
    }


    void updateAllTauDependendSignals()
    {
        state.delayDepth = state.delayDepthKnob * float (processor.frequency);
        computeDelayTimes();

        state.A440FilterFreq = pitchToFreq (55.0f) * tauFilter;
        state.noiseFilterFreq = pitchToFreq (50.0f) * tauFilter;
        state.filter1HPF = pitchToFreq (-40.0f) * tauFilter;

        state.A440Freq = 440.0f * tau;
    }

    void computeDelayTimes()
    {
        float time = float (int (state.delayTime * processor.frequency + 0.5)); // make it an exact number of samples to minimise treble loss

        if (state.delaySync)
        {
            state.delayTime_1 = time * (1.0f - state.delaySpread);
            state.delayTime_2 = time * (1.0f - 0.5f * state.delaySpread);
            state.delayTime_3 = time * (1.0f + 0.5f * state.delaySpread);
            state.delayTime_4 = time * (1.0f + state.delaySpread);
        }
        else
        {
            state.delayTime_1 = time * (1.0f - state.delaySpread);
            state.delayTime_2 = time * (1.0f - 0.4f * state.delaySpread);
            state.delayTime_3 = time * (1.0f + 0.5f * state.delaySpread);
            state.delayTime_4 = time * (1.0f + 0.9f * state.delaySpread);
        }

        // lower limit for delay times, so that at full modulation time is still >= 0

        if (state.delayTime_1 < state.delayDepth)
            state.delayTime_1 = state.delayDepth;

        if (state.delayTime_2 < state.delayDepth)
            state.delayTime_2 = state.delayDepth;

        if (state.delayTime_3 < state.delayDepth)
            state.delayTime_3 = state.delayDepth;

        if (state.delayTime_4 < state.delayDepth)
            state.delayTime_4 = state.delayDepth;

        // upper limit for delay times

        float timeLimit = (delayLength - 1) - state.delayDepth;

        if (state.delayTime_1 > timeLimit)
            state.delayTime_1 = timeLimit;

        if (state.delayTime_2 > timeLimit)
            state.delayTime_2 = timeLimit;

        if (state.delayTime_3 > timeLimit)
            state.delayTime_3 = timeLimit;

        if (state.delayTime_4 > timeLimit)
            state.delayTime_4 = timeLimit;
    }

    /// Oh god, a main function with more than 1000 lines of code!!
    /// See the notes at the top of this file for why we've left it like this!
    void main()
    {
        loop
        {
            float LFO_Pulse, LFO_Saw, LFO_Tri, Noise_White, Noise_Filtered, PolyMod;
            float PulseWidthA, PulseWidthB, WheelMod2OscAFm, WheelMod2OscBFm, WheelMod2Filt;
            float OscB_All, OscB_Pulse, OscB_Saw, OscB_Tri, OscB_PulseTri, OscA_Pulse, OscA_Saw, EQ_Out, Mixer;
            bool oscillatorSyncNow = false;
            float Osc_Sync_x;

            // Monophonic Section
            {
                let Inc = state.lfoFreq * tau;
                state.lfoPhase += Inc;

                if (state.lfoPulseSign)
                {
                    float Diff = 1.0f - state.lfoPhase;

                    if (Diff > 0.5f * Inc)
                    {
                        LFO_Pulse = state.lfoPulseA;
                        LFO_Saw = state.lfoSawA * state.lfoPhase;
                        LFO_Tri = state.lfoTriangleA * (2.0f * state.lfoPhase - 1.5f);
                    }
                    else
                    {
                        float diffInc = 0.5f + Diff / Inc;

                        LFO_Pulse = state.lfoPulseA * diffInc;
                        LFO_Saw = state.lfoSawA * (diffInc - Diff);
                        LFO_Tri = state.lfoTriangleA * (0.5f - Inc);

                        state.lfoPhase -= 1.0f;
                        state.lfoPulseSign = false;
                        state.lfoSh = state.lfoShA * state.noiseFilterLPF;

                        if (state.repeatActive)
                        {
                            for (wrap<numVoices> v)
                            {
                                if (v == activeVoices)
                                    break;

                                if (voices[v].gate > 0.0f || state.unisonGate)
                                {
                                    voices[v].isActive = true;

                                    // Amplitude Envelope Gate On
                                    float peakA = 0.5f + state.velocityAmp * (voices[v].gate * 0.0078125f - 0.5f);
                                    float peakF = 0.5f + state.velocityFilter * (voices[v].gate * 0.0078125f - 0.5f);

                                    if (voices[v].envelopeA_Out > peakA)
                                    {
                                        voices[v].envelopeA_Peak = voices[v].envelopeA_Out;
                                        voices[v].envelopeA_Stage = 1;
                                        voices[v].envelopeA_Fac = state.envelopeA_D_FAC;
                                        voices[v].envelopeA_Level = (voices[v].envelopeA_Peak - envelopeAOffset) * state.envelopeA_Sus + envelopeAOffset;
                                        voices[v].envelopeA_SDif = voices[v].envelopeA_Peak - voices[v].envelopeA_Level;
                                    }
                                    else
                                    {
                                        voices[v].envelopeA_Inc = peakA * state.envelopeA_Att;
                                        voices[v].envelopeA_Peak = peakA;
                                        voices[v].envelopeA_Stage = 0;
                                    }

                                    // Filter Envelope Gate On
                                    if (voices[v].envelopeF_Out > peakF)
                                    {
                                        voices[v].envelopeF_Peak = voices[v].envelopeF_Out;
                                        voices[v].envelopeF_Stage = 1;
                                        voices[v].envelopeF_Fac = state.envelopeF_D_FAC;
                                        voices[v].envelopeF_Level = voices[v].envelopeF_Peak * state.envelopeF_Sus;
                                        voices[v].envelopeF_SDif = voices[v].envelopeF_Out - voices[v].envelopeF_Level;
                                    }
                                    else
                                    {
                                        voices[v].envelopeF_Inc = peakF * state.envelopeF_Att;
                                        voices[v].envelopeF_Peak = peakF;
                                        voices[v].envelopeF_Stage = 0;
                                        voices[v].envelopeF_SDif = 1.0f;
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    float Diff = 0.5f - state.lfoPhase;

                    if (Diff > 0.5f * Inc)
                    {
                        LFO_Pulse = 0.0f;
                        LFO_Tri = state.lfoTriangleA * (0.5f - 2.0f * state.lfoPhase);
                    }
                    else
                    {
                        LFO_Pulse = state.lfoPulseA * (0.5f - (Diff / Inc));
                        LFO_Tri = state.lfoTriangleA * (-0.5f + Inc);

                        state.lfoPulseSign = true;

                        if (state.repeatActive)
                        {
                            for (wrap<numVoices> v)
                            {
                                if (v == activeVoices)
                                    break;

                                if (! voices[v].isActive)
                                    continue;

                                if (voices[v].gate > 0.0f || state.unisonGate)
                                {
                                    voices[v].envelopeA_Stage = 2;
                                    voices[v].envelopeA_Fac = state.envelopeA_R_FAC;
                                    voices[v].envelopeA_Level = envelopeAOffset;
                                    voices[v].envelopeA_SDif = voices[v].envelopeA_Out - voices[v].envelopeA_Level;

                                    voices[v].envelopeF_Stage = 2;
                                    voices[v].envelopeF_Fac = state.envelopeF_R_FAC;
                                    voices[v].envelopeF_Level = 0.0f;
                                    voices[v].envelopeF_SDif = voices[v].envelopeF_Out - voices[v].envelopeF_Level;
                                }
                            }
                        }
                    }

                    LFO_Saw = state.lfoSawA * state.lfoPhase;
                }
            }

            // Noise
            {
                int64 Wort = state.noiseMem;
                int64 Feedback = (Wort ^ (Wort >> 5) ^ (Wort >> 13)) << 31;
                Feedback &= 0xFFFFFFFFi64;
                Wort >>= 1;
                Wort |= Feedback;
                Noise_White = -0.5f + (Wort & 1);
                state.noiseMem = Wort;
            }

            // Noise filter
            {
                let Hpf = Noise_White - state.noiseFilterLPF;
                state.noiseFilterLPF += Hpf * state.noiseFilterFreq;
                Noise_Filtered = state.noiseFilterLPF;
            }

            // Xfade
            {
                let In1 = LFO_Pulse + LFO_Saw + LFO_Tri + state.lfoSh + state.lfoConst;
                let In2 = Noise_Filtered;

                let WheelMod = (In1 + state.lfoNoiseMix * (In2 - In1)) * state.modulationWheel;

                PulseWidthA = state.oscillatorA_PW + state.oscillatorA_PW_WM * WheelMod; // clipped after Polymod added
                PulseWidthB = state.oscillatorB_PW + state.oscillatorB_PW_WM * WheelMod;
                PulseWidthB = clamp (PulseWidthB, -1.0f, 1.0f); // clip to range -1...1

                WheelMod2OscAFm = state.oscillatorA_FM_WM * WheelMod;
                WheelMod2OscBFm = state.oscillatorB_FM_WM * WheelMod;
                WheelMod2Filt = state.filter_WM * WheelMod;
            }

            // Control Rate Section
            --state.controlCount;

            if (state.controlCount <= 0)
            {
                state.controlCount = controlPeriod;

                // Knob Smoothing
                if (state.knobSmoothingCounter != 0)
                {
                    --state.knobSmoothingCounter;

                    state.mixerOscillatorA += state.mixerOscillatorA_Inc;
                    state.mixerOscillatorB += state.mixerOscillatorB_Inc;
                    state.oscillatorA_SawA = state.mixerOscillatorA * state.oscillatorA_SawActive;

                    state.oscillatorA_PW += state.oscillatorA_PW_Inc;
                    state.oscillatorB_PW += state.oscillatorB_PW_Inc;

                    state.filter_Event += state.filter_EventInc;

                    for (wrap<numVoices> v)
                    {
                        if (v == activeVoices)
                            break;

                        voices[v].filter_Event = state.filter_Event + voices[v].filter_RND;
                    }

                    state.filter_Env += state.filter_EnvInc;
                    state.filter_Keyboard += state.filter_KeyboardInc;
                }

                // Glide
                if (state.glideInc != 0.0f)
                {
                    state.glideOut += state.glideInc;

                    if ( (state.glideOut - state.glideFinal) * state.glideInc > 0.0f)
                    {
                        state.glideOut = state.glideFinal;
                        state.glideInc = 0.0f;
                    }

                    for (wrap<numVoices> v)
                    {
                        if (v == activeVoices)
                            break;

                        voices[v].pitch = state.glideOut + voices[v].unisonRnd;

                        voices[v].oscillatorA_F = pitchToFreq (voices[v].pitch + voices[v].oscillatorA_Tune);
                        voices[v].oscillatorB_F = pitchToFreq (state.oscillatorB_Keyboard * voices[v].pitch + voices[v].oscillatorB_Tune);
                    }
                }

                for (wrap<numVoices> v)
                {
                    if (v == activeVoices)
                        break;

                    if (! voices[v].isActive)
                        continue;

                    let final = pitchToFreq (WheelMod2Filt + state.filter_Env * voices[v].envelopeF_Out + voices[v].filter_Event + state.filter_Keyboard * voices[v].pitch);
                    voices[v].filter_F_Inc = (final - voices[v].filter_F_Smooth) * (0.8f / controlPeriod);

                    if (voices[v].envelopeA_Out < 0.0f)
                    {
                        voices[v].envelopeA_Out = 0.0f;
                        voices[v].envelopeA_SDif = 0.0f;
                        voices[v].envelopeA_Level = 0.0f;
                        voices[v].envelopeF_Out = 0.0f;
                        voices[v].isActive = false;
                    }
                    else if (voices[v].envelopeA_SDif < 0.0001f) // -80dB
                    {
                        if (voices[v].envelopeA_SDif > -0.0001f) // -80dB
                        {
                            voices[v].envelopeA_SDif = 0.0f;
                            voices[v].envelopeA_Level = voices[v].envelopeA_Out;
                        }
                    }

                    if (voices[v].envelopeF_SDif < 0.0001f) // -80dB
                    {
                        if (voices[v].envelopeF_SDif > -0.0001f) // -80dB
                        {
                            voices[v].envelopeF_SDif = 0.0f;
                            voices[v].envelopeF_Level = voices[v].envelopeF_Out;
                        }
                    }

                    if (voices[v].filter1HP_LPF * voices[v].filter1HP_LPF < 0.0000001) // -80dB
                        voices[v].filter1HP_LPF = 0.0f;
                }

                // Delay LFOs
                if (state.delayActive)
                {
                    float tri, final;

                    // Delay 1
                    state.delayLFO_Pos_1 += state.delayRate_1 * (4 * controlPeriod) * tau;

                    if (state.delayLFO_Pos_1 > 1.0f)
                    {
                        if (state.delayLFO_Pos_1 > 3.0f)
                        {
                            state.delayLFO_Pos_1 -= 4.0f;
                            tri = state.delayLFO_Pos_1;
                        }
                        else
                        {
                            tri = 2.0f - state.delayLFO_Pos_1; // Pos = 1 ... 3, Tri = 1 ... -1
                        }
                    }
                    else
                    {
                        tri = state.delayLFO_Pos_1; // Pos = -1 ... 1, Tri = -1 ... 1
                    }

                    final = state.delayTime_1 + state.delayDepth * tri;
                    state.delayTime_Inc_1 = (final - state.delayTime_Mod_1) * tau * 25; // transition time = 40ms = 1/25 sec

                    if (state.delaySync)
                    {
                        // Delay 2
                        final = state.delayTime_2 + state.delayDepth * tri;
                        state.delayTime_Inc_2 = (final - state.delayTime_Mod_2) * tau * 25; // transition time = 40ms = 1/25 sec

                        // Delay 3
                        final = state.delayTime_3 + state.delayDepth * tri;
                        state.delayTime_Inc_3 = (final - state.delayTime_Mod_3) * tau * 25; // transition time = 40ms = 1/25 sec

                        // Delay 4
                        final = state.delayTime_4 + state.delayDepth * tri;
                        state.delayTime_Inc_4 = (final - state.delayTime_Mod_4) * tau * 25; // transition time = 40ms = 1/25 sec
                    }
                    else
                    {
                        // Delay 2
                        state.delayLFO_Pos_2 += state.delayRate_2 * (4 * controlPeriod) * tau;

                        if (state.delayLFO_Pos_2 > 1.0f)
                        {
                            if (state.delayLFO_Pos_2 > 3.0f)
                            {
                                state.delayLFO_Pos_2 -= 4.0f;
                                tri = state.delayLFO_Pos_2;
                            }
                            else
                            {
                                tri = 2.0f - state.delayLFO_Pos_2;
                            }
                        }
                        else
                        {
                            tri = state.delayLFO_Pos_2;
                        }

                        final = state.delayTime_2 + state.delayDepth * tri;
                        state.delayTime_Inc_2 = (final - state.delayTime_Mod_2) * tau * 25; // transition time = 40ms = 1/25 sec

                        // Delay 3
                        state.delayLFO_Pos_3 += state.delayRate_3 * (4 * controlPeriod) * tau;

                        if (state.delayLFO_Pos_3 > 1.0f)
                        {
                            if (state.delayLFO_Pos_3 > 3.0f)
                            {
                                state.delayLFO_Pos_3 -= 4.0f;
                                tri = state.delayLFO_Pos_3;
                            }
                            else
                            {
                                tri = 2.0f - state.delayLFO_Pos_3;
                            }
                        }
                        else
                        {
                            tri = state.delayLFO_Pos_3;
                        }

                        final = state.delayTime_3 + state.delayDepth * tri;
                        state.delayTime_Inc_3 = (final - state.delayTime_Mod_3) * tau * 25; // transition time = 40ms = 1/25 sec

                        // Delay 4
                        state.delayLFO_Pos_4 += state.delayRate_4 * (4 * controlPeriod) * tau;

                        if (state.delayLFO_Pos_4 > 1.0f)
                        {
                            if (state.delayLFO_Pos_4 > 3.0f)
                            {
                                state.delayLFO_Pos_4 -= 4.0f;

                                tri = state.delayLFO_Pos_4;
                            }
                            else
                            {
                                tri = 2.0f - state.delayLFO_Pos_4;
                            }
                        }
                        else
                        {
                            tri = state.delayLFO_Pos_4;
                        }

                        final = state.delayTime_4 + state.delayDepth * tri;
                        state.delayTime_Inc_4 = (final - state.delayTime_Mod_4) * tau * 25; // transition time = 40ms = 1/25 sec
                    }
                }
            }

            // Polyphonic Section

            let inputSignal = externalIn * state.mixerExternal;
            float voiceOutput;

            for (wrap<numVoices> v)
            {
                if (v == activeVoices)
                    break;

                if (! voices[v].isActive)
                    continue;

                if (voices[v].envelopeA_Stage != 0)
                {
                    voices[v].envelopeA_SDif *= voices[v].envelopeA_Fac;
                    voices[v].envelopeA_Out = voices[v].envelopeA_Level + voices[v].envelopeA_SDif;
                }
                else
                {
                    voices[v].envelopeA_Out += voices[v].envelopeA_Inc;

                    if (voices[v].envelopeA_Out > voices[v].envelopeA_Peak)
                    {
                        voices[v].envelopeA_Out = voices[v].envelopeA_Peak;
                        voices[v].envelopeA_Stage = 1;
                        voices[v].envelopeA_Fac = state.envelopeA_D_FAC;
                        voices[v].envelopeA_Level = (voices[v].envelopeA_Peak - envelopeAOffset) * state.envelopeA_Sus + envelopeAOffset;
                        voices[v].envelopeA_SDif = voices[v].envelopeA_Peak - voices[v].envelopeA_Level;
                    }
                }

                if (voices[v].envelopeF_Stage != 0)
                {
                    voices[v].envelopeF_SDif *= voices[v].envelopeF_Fac;
                    voices[v].envelopeF_Out = voices[v].envelopeF_Level + voices[v].envelopeF_SDif;
                }
                else
                {
                    voices[v].envelopeF_Out += voices[v].envelopeF_Inc;

                    if (voices[v].envelopeF_Out > voices[v].envelopeF_Peak)
                    {
                        voices[v].envelopeF_Out = voices[v].envelopeF_Peak;
                        voices[v].envelopeF_Stage = 1;

                        voices[v].envelopeF_Fac = state.envelopeF_D_FAC;
                        voices[v].envelopeF_Level = voices[v].envelopeF_Peak * state.envelopeF_Sus;
                        voices[v].envelopeF_SDif = voices[v].envelopeF_Peak - voices[v].envelopeF_Level;

                        let final = pitchToFreq (WheelMod2Filt + state.filter_Env * voices[v].envelopeF_Out + voices[v].filter_Event + state.filter_Keyboard * voices[v].pitch);
                        voices[v].filter_F_Inc = (final - voices[v].filter_F_Smooth) * (.8f / controlPeriod);
                    }
                }

                bool useNewOsc = false;

                // Oscillator B
                if (useNewOsc)
                {
                    float f = (voices[v].oscillatorB_F + voices[v].oscillatorB_F * WheelMod2OscBFm) * tau;

                    if (abs(f) > 0.99f)
                        f = f > 0 ? 0.99f : -0.99f;

                    float ph = voices[v].oscillatorB_Phase;
                    float newph = ph + f;
                    float level = float (voices[v].oscillatorB_PulseLevel - 1);

                    if (abs (newph) >= 1) // main transition
                    {
                        float cposMain = (abs(newph) - 1.0f) / abs(f); // complementary subsample pos
                        float sgnf = f > 0 ? 1.0f : -1.0f;
                        float pwmain = xfade (PulseWidthB,voices[v].oscillatorB_PW_OLD, cposMain);

                        // pw transition prior to main
                        if ((sgnf - pwmain) * level > 0)
                        {
                            float cpos = findPWT(sgnf, pwmain,ph, voices[v].oscillatorB_PW_OLD) * (1 - cposMain) + cposMain;
                            addBlep0(voices[v].oscillatorB_BUF, voices[v].oscillatorB_BUFWRITE, 7, cpos, -2.0f * state.oscillatorB_PulseA * level);
                            level = -level; voices[v].oscillatorB_PulseLevel ^= 2;
                        }

                        addBlep0 (voices[v].oscillatorB_BUF, voices[v].oscillatorB_BUFWRITE, 7, cposMain, -sgnf * (state.oscillatorB_SawA + state.oscillatorB_PulseA));
                        newph -= 2.0f *sgnf;
                        level = -level; voices[v].oscillatorB_PulseLevel ^= 2;

                        // pw transition after main
                        if ((newph - PulseWidthB) * level > 0)
                        {
                            float cpos = findPWT(newph,PulseWidthB,-sgnf,pwmain)*cposMain;
                            addBlep0 (voices[v].oscillatorB_BUF, voices[v].oscillatorB_BUFWRITE, 7, cpos, -2.0f * state.oscillatorB_PulseA * level);
                            level = -level; voices[v].oscillatorB_PulseLevel ^= 2;
                        }
                    }
                    else if ((newph - PulseWidthB) * level > 0) // but a pw transition
                    {
                        float cpos = findPWT (newph, PulseWidthB, ph, voices[v].oscillatorB_PW_OLD);
                        addBlep0 (voices[v].oscillatorB_BUF, voices[v].oscillatorB_BUFWRITE, 7, cpos, -2.0f * state.oscillatorB_PulseA * level);
                        level = -level; voices[v].oscillatorB_PulseLevel ^= 2;
                    }

                    voices[v].oscillatorB_BUF.at (voices[v].oscillatorB_BUFWRITE) += newph * state.oscillatorB_SawA + level * state.oscillatorB_PulseA;
                    voices[v].oscillatorB_Phase = newph;
                    float out = voices[v].oscillatorB_BUF.at ((voices[v].oscillatorB_BUFWRITE - 2) & 7);
                    voices[v].oscillatorB_BUFWRITE = (voices[v].oscillatorB_BUFWRITE + 1) & 7;
                    OscB_All = out;
                    voices[v].oscillatorB_BUF.at ((voices[v].oscillatorB_BUFWRITE - 2) & 7) = 0;
                    voices[v].oscillatorB_PW_OLD = PulseWidthB;
                }
                else
                {
                    float f = (voices[v].oscillatorB_F + voices[v].oscillatorB_F * WheelMod2OscBFm) * tau;
                    float ph = voices[v].oscillatorB_Phase;

                    f = max (f, 0.0f);

                    if (f >= 1.0f)
                    {
                        ph = 0.0f;
                        OscB_Saw = 0.0f;
                        OscB_Pulse = 0.0f;
                        OscB_Tri = 0.0f;
                        oscillatorSyncNow = false;
                    }
                    else
                    {
                        ph = (ph + f);

                        if (ph >= 1.0f) //  ph_mask_p=1, dn_mask=1
                        {
                            oscillatorSyncNow = state.oscillatorSyncActive; // Sync OSC-A now if sync is on

                            ph = ph - 2.0f;

                            float d = 1.0f + ph;    // float d = 1 - ph_abs;
                            float f_rcp = 1.0f / f; // reciprocal estimate operator
                            float x = d * f_rcp;
                            float x_1 = x - 1.0f;
                            Osc_Sync_x = x;

                            let aa_dn_1 = (2.0f - x * x); // first part of anti-aliasing
                            let y_saw = ph + voices[v].oscillatorB_Saw_AA2 + aa_dn_1;
                            let aa_dn_2 = x_1 * x_1;
                            voices[v].oscillatorB_Saw_AA2 = aa_dn_2; // second part of anti-aliasing, use once then reset
                            OscB_Saw = state.oscillatorB_SawA * (y_saw + 1.0f); // add one to give correct modulation DC offset

                            if (state.oscillatorB_PulseA != 0)
                            {
                                let ph_pwm = PulseWidthB;
                                let ph2 = ph - ph_pwm;
                                let ph2_sign = sign (ph2); // (ph2 >= 0 ? 1 : -1);

                                let ph3 = getPhase (ph2);
                                float pulse_aa_2 = voices[v].oscillatorB_Pulse_AA2;

                                if (ph3 * (ph3 - f) < 0.0f) // up_mask=1
                                {
                                    let ph3_abs = abs (ph3);
                                    let x3 = ph3_abs * f_rcp;
                                    let x3_1 = x3 - 1.0f;
                                    let aa_up_1 = (2.0f - x3 * x3); // first part of anti-aliasing
                                    let aa_up_2 = x3_1 * x3_1;
                                    let y_pulse = ph2_sign + pulse_aa_2 + aa_dn_1 - aa_up_1;
                                    pulse_aa_2 = aa_dn_2 - aa_up_2;     // second part of anti-aliasing, use once then reset
                                    OscB_Pulse = 0.5f - 0.5f * y_pulse; // add one to give correct modulation DC offset
                                }
                                else
                                {
                                    let y_pulse = ph2_sign + pulse_aa_2 + aa_dn_1;
                                    pulse_aa_2 = aa_dn_2;               // second part of anti-aliasing, reset
                                    OscB_Pulse = 0.5f - 0.5f * y_pulse; // add one to give correct modulation DC offset
                                }
                                voices[v].oscillatorB_Pulse_AA2 = pulse_aa_2;
                            }
                            else
                            {
                                OscB_Pulse = 0.0f;
                            }

                            if (state.oscillatorB_TriA)
                            {
                                if (ph * (ph - f) < 0.0f) // btm_mask=1
                                {
                                    let aa_top = (x * (2.0f - x) - 1.0f);
                                    let aa_btm = (1.0f - f_rcp * (2.0f + f_rcp));
                                    OscB_Tri = 0.5f - (0.5f * f - ph) - f * (aa_top - aa_btm);
                                }
                                else // btm_mask=0
                                {
                                    let aa_top = (x * (2.0f - x) - 1.0f);
                                    OscB_Tri = 0.5f - (0.5f * f - ph) - f * (aa_top);
                                }
                            }
                            else
                            {
                                OscB_Tri = 0.0f;
                            }
                        }
                        else
                        {
                            oscillatorSyncNow = false; // Sync now if sync is on

                            let y_saw = ph + voices[v].oscillatorB_Saw_AA2;
                            voices[v].oscillatorB_Saw_AA2 = 0;  // second part of anti-aliasing, reset
                            OscB_Saw = state.oscillatorB_SawA * (y_saw + 1.0f); // add one to give correct modulation DC offset

                            if (state.oscillatorB_PulseA != 0)
                            {
                                let ph_pwm = PulseWidthB;
                                let ph2 = ph - ph_pwm;
                                let ph2_sign = sign (ph2);

                                let ph3 = getPhase (ph2);
                                float pulse_aa_2 = voices[v].oscillatorB_Pulse_AA2;

                                if (ph3 * (ph3 - f) < 0.0f) // up_mask=1
                                {
                                    let ph3_abs = abs (ph3);
                                    let x3 = ph3_abs / f;
                                    let x3_1 = x3 - 1.0f;
                                    let aa_up_1 = (2.0f - x3 * x3); // first part of anti-aliasing
                                    let aa_up_2 = x3_1 * x3_1;        // second part of anti-aliasing, use once then reset
                                    let y_pulse = ph2_sign + pulse_aa_2 - aa_up_1;
                                    pulse_aa_2 = -aa_up_2; // second part of anti-aliasing, use once then reset
                                    OscB_Pulse = 0.5f - 0.5f * y_pulse;
                                }
                                else
                                {
                                    let y_pulse = ph2_sign + pulse_aa_2;
                                    pulse_aa_2 = 0; // second part of anti-aliasing, reset
                                    OscB_Pulse = 0.5f - 0.5f * y_pulse;
                                }

                                voices[v].oscillatorB_Pulse_AA2 = pulse_aa_2;
                            }
                            else
                            {
                                OscB_Pulse = 0.0f;
                            }

                            if (state.oscillatorB_TriA)
                            {
                                let ph_sign = sign (ph); // for tri

                                if (ph * (ph - f) < 0) // btm_mask=1
                                {
                                    let ph_abs = abs (ph);
                                    let x5 = ph_abs / f;
                                    let aa_btm = (x5 * (2.0f - x5) - 1.0f);
                                    OscB_Tri = 0.5f + ph_sign * (0.5f * f - ph) + f * aa_btm;
                                }
                                else // btm_mask=0
                                {
                                    OscB_Tri = 0.5f + ph_sign * (0.5f * f - ph);
                                }
                            }
                            else
                            {
                                OscB_Tri = 0.0f;
                            }
                        }
                    }

                    voices[v].oscillatorB_Phase = ph;
                }

                // Poly Mod
                if (useNewOsc)
                {
                    PolyMod = state.polymodOscillatorB * OscB_All + state.polymodEnvelopeF * (voices[v].envelopeF_Out * voices[v].polymodEnvRnd);
                }
                else
                {
                    OscB_PulseTri = OscB_Pulse + OscB_Tri;

                    PolyMod = state.polymodOscillatorB * (OscB_Saw + OscB_PulseTri)
                               + state.polymodEnvelopeF * (voices[v].envelopeF_Out * voices[v].polymodEnvRnd);
                }

                // Oscillator A
                {
                    float f = (voices[v].oscillatorA_F + voices[v].oscillatorA_F * (WheelMod2OscAFm + state.oscillatorA_FM_PM * PolyMod)) * tau;
                    f = max (f, 0.0f);

                    float ph = voices[v].oscillatorA_Phase;

                    if (f >= 1.0f) // f_mask=0
                    {
                        ph = 0.0f;
                        OscA_Saw = 0.0f;
                        OscA_Pulse = 0.0f;
                    }
                    else
                    {
                        ph = (ph + f);

                        if (oscillatorSyncNow)
                        {
                            let x_snc = Osc_Sync_x;
                            let x_snc_1 = x_snc - 1.0f;
                            let d_snc = x_snc * f;
                            let snc_ph = d_snc - 1.0f;
                            let ph_adj = ph - d_snc;

                            if (ph_adj >= 1.0f) //  ph_mask_p=1, dn_mask=1
                            {
                                ph = ph - 2.0f;

                                let ph_abs = abs (ph);
                                let d = 1.0f - ph_abs;
                                let f_rcp = 1.0f / f; // reciprocal estimate operator
                                let x = d * f_rcp;
                                let x_1 = x - 1.0f;

                                float ph2 = ph;
                                let ph_snc_change = (snc_ph - ph);
                                ph = ph + ph_snc_change;

                                let snc_aa_amp = (-0.5f) * ph_snc_change;

                                let aa_dn_1 = (2.0f - x * x);          // first part of anti-aliasing
                                let aa_snc_1 = (2.0f - x_snc * x_snc); // first part of anti-aliasing
                                let aa_snc_1_saw = aa_snc_1 * snc_aa_amp;

                                let aa_dn_2 = x_1 * x_1;                  // second part of anti-aliasing, use once then reset
                                let aa_snc_2 = x_snc_1 * x_snc_1;         // second part of anti-aliasing, use once then reset
                                let aa_snc_2_saw = aa_snc_2 * snc_aa_amp; // second part of anti-aliasing, use once then reset

                                let y_saw = ph + voices[v].oscillatorA_Saw_AA2 + aa_dn_1 + aa_snc_1_saw;
                                voices[v].oscillatorA_Saw_AA2 = aa_dn_2 + aa_snc_2_saw;
                                OscA_Saw = state.oscillatorA_SawA * y_saw;

                                if (state.oscillatorA_PulseActive)
                                {
                                    float ph_pwm = PulseWidthA + state.oscillatorA_PW_PM * PolyMod;
                                    ph_pwm = clamp (ph_pwm, -1.0f, 1.0f); // clip to range -1...1
                                    ph2 = ph2 - ph_pwm;

                                    let ph3 = getPhase (ph2);
                                    float ph4 = ph2 + ph_snc_change;

                                    float aa_up_snc_1, aa_up_snc_2;
                                    if (ph4 * (ph4 + ph_snc_change - f) < 0.0f) // up_snc_mask=1
                                    {
                                        float x4 = abs (ph4) * f_rcp;
                                        float x4_1 = x4 - 1.0f;
                                        aa_up_snc_1 = (2.0f - x4 * x4); // first part of anti-aliasing
                                        aa_up_snc_2 = x4_1 * x4_1;      // second part of anti-aliasing, use once then reset
                                    }
                                    else
                                    {
                                        aa_up_snc_1 = 0.0f; // first part of anti-aliasing
                                        aa_up_snc_2 = 0.0f; // second part of anti-aliasing, use once then reset
                                    }

                                    float aa_snc_1_pulse, aa_snc_2_pulse;

                                    if ( (ph2 - d_snc) > 0.0f) // snc_pulse_mask=1
                                    {
                                        aa_snc_1_pulse = aa_snc_1;
                                        aa_snc_2_pulse = aa_snc_2;
                                    }
                                    else
                                    {
                                        aa_snc_1_pulse = 0.0f;
                                        aa_snc_2_pulse = 0.0f;
                                    }

                                    let ph2_sign = sign (ph - ph_pwm);
                                    float pulse_aa_2 = voices[v].oscillatorA_Pulse_AA2;

                                    if ( (ph3 - d_snc) * (ph3 - f) < 0.0f) // up_mask=1
                                    {
                                        let ph3_abs = abs (ph3);
                                        let x3 = ph3_abs * f_rcp;
                                        let x3_1 = x3 - 1.0f;
                                        let aa_up_1 = (2.0f - x3 * x3); // first part of anti-aliasing
                                        let aa_up_2 = x3_1 * x3_1;      // second part of anti-aliasing, use once then reset
                                        let y_pulse = ph2_sign + pulse_aa_2 + aa_dn_1 - aa_up_1 - aa_up_snc_1 + aa_snc_1_pulse;
                                        pulse_aa_2 = aa_dn_2 - aa_up_2 - aa_up_snc_2 + aa_snc_2_pulse; // second part of anti-aliasing, use once then reset
                                        OscA_Pulse = state.mixerOscillatorA * y_pulse;
                                    }
                                    else
                                    {
                                        let y_pulse = ph2_sign + pulse_aa_2 + aa_dn_1 - aa_up_snc_1 + aa_snc_1_pulse;
                                        pulse_aa_2 = aa_dn_2 - aa_up_snc_2 + aa_snc_2_pulse; // second part of anti-aliasing, use once then reset
                                        OscA_Pulse = state.mixerOscillatorA * y_pulse;
                                    }
                                    voices[v].oscillatorA_Pulse_AA2 = pulse_aa_2;
                                }
                                else
                                {
                                    OscA_Pulse = 0.0f;
                                }
                            }
                            else // dn_mask=0
                            {
                                float ph2 = ph;
                                let ph_snc_change = (snc_ph - ph);
                                ph = ph + ph_snc_change;

                                let snc_aa_amp = (-0.5f) * ph_snc_change;

                                let aa_snc_1 = (2.0f - x_snc * x_snc); // first part of anti-aliasing
                                let aa_snc_1_saw = aa_snc_1 * snc_aa_amp;

                                let aa_snc_2 = x_snc_1 * x_snc_1;         // second part of anti-aliasing, use once then reset
                                let aa_snc_2_saw = aa_snc_2 * snc_aa_amp; // second part of anti-aliasing, use once then reset

                                let y_saw = ph + voices[v].oscillatorA_Saw_AA2 + aa_snc_1_saw;
                                voices[v].oscillatorA_Saw_AA2 = aa_snc_2_saw;
                                OscA_Saw = state.oscillatorA_SawA * y_saw;

                                if (state.oscillatorA_PulseActive)
                                {
                                    let ph_pwm = clamp (PulseWidthA + state.oscillatorA_PW_PM * PolyMod, -1.0f, 1.0f);
                                    ph2 = ph2 - ph_pwm;

                                    let ph3 = getPhase (ph2);
                                    let ph4 = ph2 + ph_snc_change;
                                    float aa_up_snc_1, aa_up_snc_2;

                                    if (ph4 * (ph4 + ph_snc_change - f) < 0.0f) // up_snc_mask=1
                                    {
                                        let x4 = abs (ph4) / f;
                                        let x4_1 = x4 - 1.0f;
                                        aa_up_snc_1 = (2.0f - x4 * x4); // first part of anti-aliasing
                                        aa_up_snc_2 = x4_1 * x4_1;      // second part of anti-aliasing, use once then reset
                                    }

                                    float aa_snc_1_pulse, aa_snc_2_pulse;

                                    if ((ph2 - d_snc) > 0.0f) // snc_pulse_mask=1
                                    {
                                        aa_snc_1_pulse = aa_snc_1;
                                        aa_snc_2_pulse = aa_snc_2;
                                    }
                                    else
                                    {
                                        aa_snc_1_pulse = 0.0f;
                                        aa_snc_2_pulse = 0.0f;
                                    }

                                    let ph2_sign = sign (ph - ph_pwm);
                                    float pulse_aa_2 = voices[v].oscillatorA_Pulse_AA2;

                                    if ((ph3 - d_snc) * (ph3 - f) < 0.0f) // up_mask=1
                                    {
                                        let ph3_abs = abs (ph3);
                                        let x3 = ph3_abs / f;
                                        let x3_1 = x3 - 1.0f;
                                        let aa_up_1 = (2.0f - x3 * x3); // first part of anti-aliasing
                                        let aa_up_2 = x3_1 * x3_1;      // second part of anti-aliasing, use once then reset
                                        let y_pulse = ph2_sign + pulse_aa_2 - aa_up_1 - aa_up_snc_1 + aa_snc_1_pulse;
                                        pulse_aa_2 = -aa_up_2 - aa_up_snc_2 + aa_snc_2_pulse; // second part of anti-aliasing, use once then reset
                                        OscA_Pulse = state.mixerOscillatorA * y_pulse;
                                    }
                                    else
                                    {
                                        let y_pulse = ph2_sign + pulse_aa_2 - aa_up_snc_1 + aa_snc_1_pulse;
                                        pulse_aa_2 = -aa_up_snc_2 + aa_snc_2_pulse; // second part of anti-aliasing, use once then reset
                                        OscA_Pulse = state.mixerOscillatorA * y_pulse;
                                    }

                                    voices[v].oscillatorA_Pulse_AA2 = pulse_aa_2;
                                }
                                else
                                {
                                    OscA_Pulse = 0.0f;
                                }
                            }
                        }
                        else // no sync
                        {
                            if (ph >= 1.0f) //  ph_mask_p=1, dn_mask=1
                            {
                                ph = ph - 2.0f;

                                let d = 1.0f + ph;    // float d = 1 - ph_abs;
                                let f_rcp = 1.0f / f; // reciprocal estimate operator
                                let x = d * f_rcp;
                                let x_1 = x - 1.0f;
                                let aa_dn_1 = (2.0f - x * x); // first part of anti-aliasing
                                let aa_dn_2 = x_1 * x_1;      // second part of anti-aliasing, use once then reset

                                let y_saw = ph + voices[v].oscillatorA_Saw_AA2 + aa_dn_1;
                                voices[v].oscillatorA_Saw_AA2 = aa_dn_2;
                                OscA_Saw = state.oscillatorA_SawA * y_saw;

                                if (state.oscillatorA_PulseActive)
                                {
                                    let ph_pwm = clamp (PulseWidthA + state.oscillatorA_PW_PM * PolyMod, -1.0f, 1.0f);
                                    let ph2 = ph - ph_pwm;
                                    let ph2_sign = sign (ph2);

                                    let ph3 = getPhase (ph2);
                                    float pulse_aa_2 = voices[v].oscillatorA_Pulse_AA2;

                                    if (ph3 * (ph3 - f) < 0.0f) // up_mask=1
                                    {
                                        let ph3_abs = abs (ph3);
                                        let x3 = ph3_abs * f_rcp;
                                        let x3_1 = x3 - 1.0f;
                                        let aa_up_1 = (2.0f - x3 * x3); // first part of anti-aliasing
                                        let aa_up_2 = x3_1 * x3_1;      // second part of anti-aliasing, use once then reset
                                        let y_pulse = ph2_sign + pulse_aa_2 + aa_dn_1 - aa_up_1;
                                        pulse_aa_2 = aa_dn_2 - aa_up_2; // second part of anti-aliasing, use once then reset
                                        OscA_Pulse = state.mixerOscillatorA * y_pulse;
                                    }
                                    else
                                    {
                                        let y_pulse = ph2_sign + pulse_aa_2 + aa_dn_1;
                                        pulse_aa_2 = aa_dn_2; // second part of anti-aliasing, reset
                                        OscA_Pulse = state.mixerOscillatorA * y_pulse;
                                    }
                                    voices[v].oscillatorA_Pulse_AA2 = pulse_aa_2;
                                }
                                else
                                {
                                    OscA_Pulse = 0.0f;
                                }
                            }
                            else // dn_mask=0
                            {
                                let y_saw = ph + voices[v].oscillatorA_Saw_AA2;
                                voices[v].oscillatorA_Saw_AA2 = 0;
                                OscA_Saw = state.oscillatorA_SawA * y_saw;

                                if (state.oscillatorA_PulseActive)
                                {
                                    let ph_pwm = clamp (PulseWidthA + state.oscillatorA_PW_PM * PolyMod, -1.0f, 1.0f);
                                    let ph2 = ph - ph_pwm;
                                    let ph2_sign = sign (ph2);

                                    let ph3 = getPhase (ph2);
                                    float pulse_aa_2 = voices[v].oscillatorA_Pulse_AA2;

                                    if (ph3 * (ph3 - f) < 0.0f) // up_mask=1
                                    {
                                        let ph3_abs = abs (ph3);
                                        let x3 = ph3_abs / f;
                                        let x3_1 = x3 - 1.0f;
                                        let aa_up_1 = (2.0f - x3 * x3); // first part of anti-aliasing
                                        let aa_up_2 = x3_1 * x3_1;      // second part of anti-aliasing, use once then reset
                                        let y_pulse = ph2_sign + pulse_aa_2 - aa_up_1;
                                        pulse_aa_2 = -aa_up_2; // second part of anti-aliasing, use once then reset
                                        OscA_Pulse = state.mixerOscillatorA * y_pulse;
                                    }
                                    else
                                    {
                                        let y_pulse = ph2_sign + pulse_aa_2;
                                        pulse_aa_2 = 0; // second part of anti-aliasing, use once then reset
                                        OscA_Pulse = state.mixerOscillatorA * y_pulse;
                                    }

                                    voices[v].oscillatorA_Pulse_AA2 = pulse_aa_2;
                                }
                                else
                                {
                                    OscA_Pulse = 0.0f;
                                }
                            }
                        }
                    }

                    voices[v].oscillatorA_Phase = ph;
                }

                // EQ
                // boost high frequencies (up to +3.1dB at Nyquist) to compensate loss due to antialiasing
                if (useNewOsc)
                {
                    EQ_Out = state.mixerOscillatorB * OscB_All;
                }
                else
                {
                    float EQ_In = OscA_Pulse + OscA_Saw + state.mixerOscillatorB * (OscB_Saw - OscB_PulseTri);
                    EQ_Out = EQ_In + -0.171f * voices[v].eqLast;
                    voices[v].eqLast = EQ_In;
                }

                // Mixer
                Mixer = EQ_Out + state.mixerNoise * Noise_White + inputSignal;

                if (filterVersion == 0) // Old filter
                {
                    float satIn;

                    {
                        voices[v].filter_F_Smooth += voices[v].filter_F_Inc;

                        var FM = state.filter_PM * PolyMod * voices[v].filter_F_Smooth;
                        var FN = (voices[v].filter_F_Smooth + FM) * tauFilter;
                        var F = FN;

                        if (F < 0.0f)
                        {
                            FN = 0.0f;
                            F = 0.0f;
                        }
                        else
                        {
                            if (F > state.filterN_FMAX)
                            {
                                FN = state.filterN_FMAX;

                                if (F > state.filter_FMAX)
                                    F = state.filter_FMAX;
                            }
                        }

                        let In = Mixer - voices[v].saturator_Out;
                        var hpf = In - (voices[v].filter_BPF * state.filter_D + voices[v].filter_LPF);
                        voices[v].filter_BPF += hpf * F;
                        voices[v].filter_LPF += voices[v].filter_BPF * F + 1.0e-7f;

                        if (state.filter_HPF)
                        {
                            let notch = hpf - voices[v].filterN_BPF;
                            hpf = notch * state.filterN_D - voices[v].filterN_LPF;
                            voices[v].filterN_BPF += hpf * FN;
                            voices[v].filterN_LPF += voices[v].filterN_BPF * FN;

                            satIn = hpf;
                        }
                        else
                        {
                            let notch = voices[v].filter_LPF - voices[v].filterN_BPF;
                            hpf = notch * state.filterN_D - voices[v].filterN_LPF;
                            voices[v].filterN_BPF += hpf * FN;
                            voices[v].filterN_LPF += voices[v].filterN_BPF * FN;

                            satIn = voices[v].filterN_LPF;
                        }
                    }

                    // Saturator
                    if (satIn > 0.0f)
                        voices[v].saturator_Out = satIn < 4.0f ? satIn * (satIn * (-0.125f * 0.13335f) + 0.13335f)
                                                               : 0.13335f * 2.0f;
                    else
                        voices[v].saturator_Out = satIn > -4.0f ? satIn * (satIn * (0.125f * 0.13335f) + 0.13335f)
                                                                : -0.13335f * 2.0f;

                    // Filt1
                    let filter1_Hpf = satIn - voices[v].filter1HP_LPF;
                    voices[v].filter1HP_LPF += filter1_Hpf * state.filter1HPF;

                    // Voice Combiner
                    voiceOutput -= filter1_Hpf * voices[v].envelopeA_Out;
                }
                else
                {
                    bool bAA = (filterVersion == 2);
                    bool bBPF = state.filter_HPF;

                    voices[v].filter_F_Smooth += voices[v].filter_F_Inc;
                    let FM = state.filter_PM * PolyMod * voices[v].filter_F_Smooth;
                    let F = max (1.0f, voices[v].filter_F_Smooth + FM);
                    let g = fasttanf (min (1.5f, F * piOverSampleRate));
                    let norm = 1.0f / (1.0f + g);
                    let gnorm = g * norm;
                    let gnorm2 = gnorm * gnorm;
                    let GF = gnorm2 * gnorm2;
                    let G = GF * state.filter_K;

                    let scale = 2.0f / 3.0f;
                    float x = Mixer * scale + 1e-5f;
                    x *= 1 + state.filter_K * 0.1f;
                    float[5] s;

                    if (bAA)
                    {
                        let x_ = voices[v].filter_X; voices[v].filter_X = x;
                        x = (x + x_) * 0.5f;
                        let g2 = g + g, g2norm = g2 * norm;
                        float S = voices[v].filter_S0 - g2norm * voices[v].filter_S0;
                        S = ((S + voices[v].filter_X_1) * g+voices[v].filter_S1) * norm;
                        S = ((S + voices[v].filter_X_2) * g+voices[v].filter_S2) * norm;
                        S = ((S + voices[v].filter_X_3) * g+voices[v].filter_S3) * norm;
                        S = (GF * (x + x) + S - G * voices[v].filter_X_4) / (1 + G);
                        S = tanhaa (S, voices[v].filter_X_4, voices[v].filter_F0_4);
                        x = x - S * state.filter_K; s[0] = x;
                        float u = (x - voices[v].filter_S0) * g2norm; voices[v].filter_S0 = voices[v].filter_S0 + u; x = voices[v].filter_S0; s[1] = x;
                        u = tanhaa ((x - voices[v].filter_S1 - voices[v].filter_X_1 * g) * norm, voices[v].filter_X_1,voices[v].filter_F0_1) * g2; voices[v].filter_S1 = voices[v].filter_S1 + u; x = voices[v].filter_S1; s[2] = x;
                        u = tanhaa ((x - voices[v].filter_S2 - voices[v].filter_X_2 * g) * norm, voices[v].filter_X_2,voices[v].filter_F0_2) * g2; voices[v].filter_S2 = voices[v].filter_S2 + u; x = voices[v].filter_S2; s[3] = x;
                        u = tanhaa ((x - voices[v].filter_S3 - voices[v].filter_X_3 * g) * norm, voices[v].filter_X_3,voices[v].filter_F0_3) * g2; voices[v].filter_S3 = voices[v].filter_S3 + u; x = voices[v].filter_S3; s[4] = x;
                    }
                    else
                    {
                        float S = gnorm * (0 - voices[v].filter_S0) + voices[v].filter_S0;
                        S = gnorm * (S - voices[v].filter_S1) + voices[v].filter_S1;
                        S = gnorm * (S - voices[v].filter_S2) + voices[v].filter_S2;
                        S = gnorm * (S - voices[v].filter_S3) + voices[v].filter_S3;
                        S = fasttanhf (S);
                        S *= state.filter_K;
                        x = (x - S) / (1 + G); s[0] = x;
                        float u = fasttanhf (x-voices[v].filter_S0)*gnorm; x = voices[v].filter_S0+u; voices[v].filter_S0 = u+x; s[1] = x;
                        u = fasttanhf (x-voices[v].filter_S1)*gnorm; x = voices[v].filter_S1+u; voices[v].filter_S1 = u+x; s[2] = x;
                        u = fasttanhf (x-voices[v].filter_S2)*gnorm; x = voices[v].filter_S2+u; voices[v].filter_S2 = u+x; s[3] = x;
                        u = fasttanhf (x-voices[v].filter_S3)*gnorm; x = voices[v].filter_S3+u; voices[v].filter_S3 = u+x; s[4] = x;
                    }

                    if (bBPF)
                    {
                        if (false)
                        {
                            float mix = s[4] - 4 * (s[1] + s[3]) + 6 * s[2];
                            mix = (mix + voices[v].filter_Mix) * 0.5f;
                            voices[v].filter_Mix = mix;
                            x = mix + s[0];
                        }
                        else
                        {
                            x = s[2] - 2 * s[3] + s[4];
                        }
                    }

                    x *= 2 / scale;
                    voiceOutput += x * voices[v].envelopeA_Out;
                }
            }

            // Monophonic Section

            // Smoother
            if (state.smootherCount > 0)
            {
                --state.smootherCount;

                state.volumeSmooth += state.volumeInc;
                state.delayWetSmooth += state.delayWetInc;
                state.delayDrySmooth += state.delayDryInc;
                state.delayFeedbackSmooth += state.delayFeedbackInc;
            }

            // Delay Effect

            float dryOut = voiceOutput * state.delayDrySmooth;
            float delayL, delayR;

            if (state.delayActive)
            {
                // Filt1
                {
                    float Hpf = (voiceOutput + state.delaySum * state.delayFeedbackSmooth) - state.delay_HPF_LPF;
                    state.delay_HPF_LPF += Hpf * state.delay_HPF_F + 1e-12f;

                    Hpf = Hpf - state.delay_LPF_LPF;

                    state.delay_LPF_LPF += Hpf * state.delay_LPF_F;
                }

                // LFOs

                // waveform is controlled by setting Inc's at control rate
                state.delayTime_Mod_1 += state.delayTime_Inc_1;
                state.delayTime_Mod_2 += state.delayTime_Inc_2;
                state.delayTime_Mod_3 += state.delayTime_Inc_3;
                state.delayTime_Mod_4 += state.delayTime_Inc_4;

                // Delays

                delayBuffer.at (state.delayBufferIn) = state.delay_LPF_LPF; // Delay Input

                // Delay 1
                let prec1 = state.delayTime_Mod_1;
                let trunc1 = int (prec1);
                let lo1 = delayBuffer.at ((state.delayBufferIn - trunc1) & delayMask);
                let hi1 = delayBuffer.at ((state.delayBufferIn - trunc1 - 1) & delayMask);

                let delay1 = lo1 + (prec1 - trunc1) * (hi1 - lo1);

                // Delay 2 ...
                let prec2 = state.delayTime_Mod_2;
                let trunc2 = int (prec2);
                let lo2 = delayBuffer.at ((state.delayBufferIn - trunc2) & delayMask);
                let hi2 = delayBuffer.at ((state.delayBufferIn - trunc2 - 1) & delayMask);

                let delay2 = lo2 + (prec2 - trunc2) * (hi2 - lo2);

                // Delay 3 ...
                let prec3 = state.delayTime_Mod_3;
                let trunc3 = int (prec3);
                let lo3 = delayBuffer.at ((state.delayBufferIn - trunc3) & delayMask);
                let hi3 = delayBuffer.at ((state.delayBufferIn - trunc3 - 1) & delayMask);

                let delay3 = lo3 + (prec3 - trunc3) * (hi3 - lo3);

                // Delay 4 ...
                let prec4 = state.delayTime_Mod_4;
                let trunc4 = int (prec4);
                let lo4 = delayBuffer.at ((state.delayBufferIn - trunc4) & delayMask);
                let hi4 = delayBuffer.at ((state.delayBufferIn - trunc4 - 1) & delayMask);

                float delay4 = lo4 + (prec4 - trunc4) * (hi4 - lo4);

                state.delayBufferIn = (state.delayBufferIn + 1) & delayMask;
                state.delaySum = delay1 + delay2 + delay3 + delay4;

                // 1: half-left, 2: half-right; 3; full-left, 4: full-right
                delayL = state.delayWetSmooth * (0.75f * delay1 + 0.25f * delay2 + delay3);
                delayR = state.delayWetSmooth * (0.25f * delay1 + 0.75f * delay2 + delay4);
            }

            // A-440
            if (testToneActive)
            {
                let Inc = state.A440Freq;
                state.A440Phase += Inc;
                float A440_Pulse;

                if (state.A440PulseSign != 0)
                {
                    let diff = 1.0f - state.A440Phase;

                    if (diff > 0.5f * Inc)
                    {
                        A440_Pulse = A440Pulse;
                    }
                    else
                    {
                        let diffInc = 0.5f + diff / Inc;
                        A440_Pulse = A440Pulse * diffInc;
                        state.A440Phase -= 1.0f;
                        state.A440PulseSign = 0;
                    }
                }
                else
                {
                    let diff = 0.5f - state.A440Phase;

                    if (diff > 0.5f * Inc)
                    {
                        A440_Pulse = 0.0f;
                    }
                    else
                    {
                        A440_Pulse = A440Pulse * (0.5f - (diff / Inc));
                        state.A440PulseSign = 1;
                    }
                }

                let hpf = (A440_Pulse - 0.5f * A440Pulse) - state.A440FilterLPF;
                state.A440FilterLPF += hpf * state.A440FilterFreq;
                dryOut += state.A440FilterLPF;
            }

            out <- float<2> (state.volumeSmooth * (dryOut + delayL),
                             state.volumeSmooth * (dryOut + delayR));
            advance();
        }
    }


    //==============================================================================
    //==============================================================================
    // Helper functions:
    void updateEffectiveSustain() //SUSTPEDAL. New.
    {
        bool oldEffectiveSustain = sustainActive; // sustainActive holds the previous combined state
        sustainActive = pedalSustainActive || state.droneActive;

        if (oldEffectiveSustain && !sustainActive) // Effective sustain transitioned from true to false
        {
            sustainedNotesOff(); // This function will also set sustainActive = false internally
        }
    }

    float undenormalise (float f)   { return -1e-12 < f && f < 1e-12 ? 0.0f : f; }

    T sign<T> (T val)    { return val >= 0 ? 1.0f : -1.0f; }

    T fastExp<T> (T v)
    {
        let trunc = int (v);

        if (trunc > 2399)
            return exponentLUT [2400];

        if (trunc < 0)
            return 0;

        return exponentLUT.at (trunc) + (float (v) - trunc) * exponentLUTSlope.at (trunc);
    }

    void initExponentLUT()
    {
        exponentLUT[0] = pow (2.0, -20.0);

        for (int i = 1; i < 2401; ++i)
        {
            let value = pow (2.0f, (float (i) - 1200.0f) / 60.0f);
            exponentLUT.at (i) = value;
            exponentLUTSlope.at (i - 1) = value - exponentLUT.at (i - 1);
        }
    }

    T pitchToFreq<T> (T v)        { return fastExp (v * 5.0f + 1381.88158f); }
    T timeToIncrement<T> (T v)    { return fastExp (1797.94705708f - v * 9.96578428466f); }
    T exp_dB<T> (T v)             { return fastExp (v * 9.96578428466f + 1200.0f); }
    T exp_E<T> (T v)              { return fastExp (v * 86.56170245334f + 1200.0f); }

    float findPWT (float phase0, float width0, float phase1, float width1)
    {
        return (width0 - phase0) / ((width0 - phase0) - (width1 - phase1));
    }

    float xfade (float x0, float x1, float t)
    {
        return x0 + (x1 - x0) * t;
    }

    float blep0 (float pos)
    {
        let x = 0.5f * pos;
        return ((((((-4.36023f * x + 13.5038f) * x - 11.5128f) * x - 3.25094f)
                  * x + 7.83529f) * x - 0.2393f) * x - 2.97566f) * x + 0.99986f;
    }

    void addBlep0 (float[8]& buf, int writePos, int mask, float cpos, float halfampl)
    {
        buf.at ((writePos - 2) & mask) += halfampl * blep0 (2 - cpos);
        buf.at ((writePos - 1) & mask) += halfampl * blep0 (1 - cpos);
        buf.at (writePos) -= halfampl * blep0 (cpos);
        buf.at ((writePos + 1) & mask) -= halfampl * blep0 (cpos + 1);
    }

    // 0..1.50845 range only!
    float fasttanf (float x)
    {
        float a = ((-0.0896638f * x + 0.0388452f) * x + 1.00005f) * x;
        float b = (-0.430871f * x + 0.0404318f) * x + 1.0f;
        return a / b;
    }

    float fasttanhf (float x)
    {
        let ax = abs (x);

        if (ax > 4.9717869f)
            return x > 0 ? 1.0f : -1.0f;

        let x2 = x * x;
        let a = (((x2 + 378) * x2 + 17325) * x2 + 135135) * x;
        let b = ((28 * x2 + 3150) * x2 + 62370) * x2 + 135135;
        return a / b;
    }

    float tanhaa (float x, float& xOut, float& outF0)
    {
        float x2 = xOut;
        xOut = x;
        float dx = x - x2;

        if (abs (dx) < 0.001)
        {
            x = tanh ((x + x2) * 0.5f);
            outF0 = -2.0f;
        }
        else
        {
            if (outF0 < -1.0f)
                outF0 = abs (x2) < 12 ? log (cosh (x2)) : x2 - 0.69314718f;

            let F0 = abs (x) < 12 ? log (cosh (x)) : x - 0.69314718f;
            x = (F0 - outF0) / dx;
            outF0 = F0;
        }

        return x;
    }

    float getPhase (float ph2)
    {
        if (ph2 >= 1.0f)
            return ph2 - 2.0f;

        if (ph2 <= -1.0f)
            return ph2 + 2.0f;

        return ph2;
    }
}
